## 1.流程图

![[Pasted image 20251014095818.png]]

## 2.关于第三方服务调用的思考：

### 2.1 统一接口：

提供一致性的抽象，提现服务需要接入多种第三方平台，对于上游的业务服务来说，他们不应该关心这几种体现方式在API层面有何不同。他们理想的调用方式是，调用一个统一的`withdraw`接口，传入订单号、金额、提现方式等标准化的业务参数即可

如何抽象：

- 请求格式差异：各个提现平台需要的请求体格式
    
- 响应格式差异：第三方返回的数据字段不同
    
- 回调处理逻辑的差异：
    
![[Pasted image 20251014095825.png]]


### 2.2 限流

绝大多数第三方平台，出于自我保护的目的，都会对API的调用频率进行限制。例如，某个银行接口可能明确规定，单个IP每秒最多发送10次请求，超出部分将直接拒绝服务。

如果我们对此一无所知，任由上游业务的流量直接打过去，那么超出限制的那些请求注定会失败。这不仅浪费了我们系统的网络和计算资源，也给下游的第三方服务带来了不必要的压力。明智的做法是，在我们的抽象层中，提前根据第三方的限流规则，配置一个与之匹配的客户端限流器。这样，在发起调用之前就主动拦截掉超额的请求，既能快速失败，又能省去一次必然无效的网络调用

四种限流算法：固定窗口，滑动窗口，漏桶，令牌桶 

### 2.3 超时重试

当调用第三方平台发生网络超时或偶发性错误时，业务方显然不希望直接收到一个冷冰冰的超时响应。因为如果这样，就意味着每个业务方都需要自己去处理超时，实现一套自己的重试逻辑。

如何保证幂等性：redis setNX 悲观锁

![[Pasted image 20251014095834.png]]

### 2.4 Mock服务

在开发和测试环境中，当业务方调用你的接口时，不应该真的去请求昂贵或不稳定的第三方API

如果第三方服务还包含回调机制（例如，微信支付成功后会异步回调我们的一个接口），那么你的Mock服务也需要能够模拟这个回调行为，向业务方的回调接口发送模拟通知，从而形成一个完整的、自洽的测试闭环

QA：为什么要mock？

- 节约真金白银：对于像短信发送、身份认证这类按次收费的服务，Mock可以避免在测试过程中产生不必要的开销
    
- 摆脱环境依赖：第三方平台的测试环境可能极其不稳定，甚至根本不存在。使用Mock可以让我们完全独立、高效地进行开发和测试
    
- 丰富的场景模拟：可以让业务方随心所欲地模拟各种场景，包括成功、特定的业务失败（如“余额不足”）、网络超时、返回异常报文等，从而充分验证业务方的各种正常及异常处理逻辑
    

一般调用第三方支付服务难点：系统对可用性要求非常高，其中一个关键的挑战就是，系统需要和多个外部的、我们无法控制的第三方平台进行交互，为达成目标，考虑综合运用熔断、限流、降级、超时控制等多种手段

## 3.底层原理

### 3.1 Spring事件发布订阅机制

本质是广播机制

#### Bean 初始化

- Spring 容器扫描所有 `ApplicationListener` 或 `@EventListener`，注册到 `ApplicationEventMulticaster`（Spring 内置的一个接口）
    

#### 事件发布

- 调用 `ApplicationEventPublisher.publishEvent(event)` 把事件交给 ApplicationEventMulticaster 去“广播”给所有匹配的监听器
    

#### 事件广播

- `ApplicationEventMulticaster` 找到所有匹配类型的监听器
    
- 可以 自定义实现 `ApplicationEventMulticaster`，替换默认的广播机制。比如可以改成 把事件转发到 Kafka/RabbitMQ/Redis，让事件跨进程传递
    

#### 监听器执行

- 默认 同步执行，即在发布者线程里调用
    
- 可以加 `@Async` 异步执行，提交到指定线程池
    

### 3.2 Spring事务机制简易版

入口：`@Transactional` 是一个 声明式事务管理 注解

- 开启事务（底层就是 `Connection.setAutoCommit(false)`）
    
- 如果方法正常返回，调用 `commit()` 提交事务（底层就是 `Connection.commit()`）
    
- 如果方法抛出异常，根据规则决定是否回滚：
    
    - 默认：只对 `RuntimeException` 和 `Error` 回滚
        
    - 通过 `rollbackFor`、`rollbackForClassName` 可以指定额外的异常类型。
        
- 回滚就是调用 `rollback()`（底层就是 `Connection.rollback()`）
    

受检异常，默认情况（@Transactional）下 Spring 不会回滚事务，如果前面已经有一些 insert/update，它们仍然会提交

参考：[https://juejin.cn/post/7326758010523500584?searchId=202508221801344EA4C7BFD9EA49368401](https://juejin.cn/post/7326758010523500584?searchId=202508221801344EA4C7BFD9EA49368401)

[https://zhuanlan.zhihu.com/p/29340267224](https://zhuanlan.zhihu.com/p/29340267224)