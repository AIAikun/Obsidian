### 6.5840 - 2025年春季  
#### 6.5840 实验2：键值存储服务器  

---

### 实验简介  
在本实验中，您将构建一个单机键值存储服务器，确保即使在网络故障的情况下，每个Put操作也能实现**最多执行一次**的语义，并保证操作的**线性一致性**。您将使用该KV服务器实现分布式锁，后续实验会通过服务器复制来应对服务崩溃场景。

---

### 键值服务器规范  
#### 核心机制  
1. **客户端交互**  
   - 通过`Clerk`结构体与服务器通信，支持两种RPC：  
     - `Put(key, value, version)`  
     - `Get(key)`  
   - 服务器维护内存中的键值映射表，存储`(value, version)`元组（键和值为字符串类型）

2. **版本控制逻辑**  
   - `Put`操作仅在客户端版本号与服务器版本号匹配时生效  
     - 匹配时：更新值并递增版本号  
     - 不匹配时：返回`rpc.ErrVersion`  
   - 创建新键需使用`version=0`（服务器存储版本将变为1）  
   - 对不存在的键执行`version>0`的Put时返回`rpc.ErrNoKey`

3. **Get操作**  
   - 返回键的当前值和版本号  
   - 键不存在时返回`rpc.ErrNoKey`

---

### 实验目标分解  
#### 阶段1：可靠网络下的基础实现（简单）  
- **任务**：在无网络丢包场景下实现KV服务器  
- **关键点**：  
  - 完善`client.go`中的RPC发送逻辑  
  - 实现`server.go`中的Put/Get处理器  
- **验收标准**：通过`Reliable`测试组  
  ```bash
  $ go test -v -run Reliable
  ```

#### 阶段2：基于KV服务实现分布式锁（中等）  
- **锁特性**：  
  - 同一时刻仅一个客户端能成功获取锁  
  - 需实现`Acquire()`和`Release()`方法  
- **技术要点**：  
  - 使用`kvtest.RandValue(8)`生成客户端唯一ID  
  - 通过特定键（参数`l`指定）存储锁状态  
- **验收标准**：通过`lock/`子目录下的测试  
  ```bash
  $ cd lock && go test -v -run Reliable
  ```

#### 阶段3：支持网络丢包（中等）  
- **挑战场景**：  
  - 网络可能丢弃/重排序RPC请求或响应  
  - 需处理重复请求（幂等性设计）  
- **容错策略**：  
  - 客户端持续重试直到收到响应  
  - 对重试Put收到`rpc.ErrVersion`时返回`rpc.ErrMaybe`  
- **实现提示**：  
  - 每次重试前休眠100ms（`time.Sleep(100 * time.Millisecond)`  

#### 阶段4：不可靠网络下的锁实现（简单）  
- **适配要求**：  
  - 使锁服务在丢包网络中可靠工作  
- **验收标准**：通过所有锁测试（含不可靠网络场景）  
  ```bash
  $ cd lock && go test -v
  ```

---

### 核心概念解析  
#### 线性一致性（Linearizability）  
- **定义**：客户端观察到的操作效果，等同于这些操作按某种顺序原子执行的场景  
- **保证**：  
  - 非并发操作：保持严格先后顺序  
  - 并发操作：结果等价于某种线性执行顺序  
- **示例**：若客户端X的Put成功返回，后续其他客户端的Get必须能看到该修改

#### 最多执行一次（At-Most-Once）  
- **实现原理**：  
  - 版本号机制防止重复执行  
  - 网络重试时通过`ErrVersion`/`ErrMaybe`区分执行状态  

---

### 开发指南  
1. **代码结构**  
   - 主逻辑文件：`client.go` / `server.go`  
   - RPC定义：`rpc/rpc.go`（无需修改）  
   - 锁实现：`lock/lock.go`

2. **测试方法**  
   - 竞态检测：`go test -race`  
   - 完整测试：`go test -v`

3. **调试技巧**  
   - 通过`-run`参数指定测试用例  
   - 检查测试输出的RPC计数和操作统计

---

### 注意事项  
1. **锁的局限性**  
   - 客户端崩溃会导致锁永久持有（实际系统需引入租约机制）  
2. **错误处理边界**  
   - `ErrMaybe`表示不确定是否执行成功，需由应用层处理  
3. **性能优化**  
   - 大量并发Put时注意内存管理（参考`TestMemPutManyClientsReliable`）

---

### 示例测试输出  
成功运行时的典型输出：  
```text
=== RUN   TestUnreliableNet
One client (unreliable network)...
  ... Passed --   7.6  1   251  208
--- PASS: TestUnreliableNet (7.60s)
PASS
```
（各字段含义：真实时间秒数｜常量1｜RPC调用次数｜KV操作次数）

---

通过本实验，您将掌握：  
✅ 线性一致性KV服务实现  
✅ 基于版本控制的幂等操作设计  
✅ 不可靠网络下的容错处理  
✅ 分布式锁的基础构建方法