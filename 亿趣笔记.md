# 角色聊天插件plugin——Memory
初步打算使用现有的工具/服务Memu来实现加强记忆效果。

- 存储与更新：输入聊天记录，会按提取出侧重于Roleplay与陪聊业务特点的记忆点按分类形式存储（更新）。存储key为 [用户、角色]对。
    
- 记忆加强聊天效果：先从记忆存储中提取出语义化的分类记忆关键点，加入到systemPrompt中。 
    
- 存储与更新是异步任务，且有成本
    
- 更新效果按目前的聊天token量，大约在110～120轮进行一次记忆库更新是最佳的且不会有太长的延迟，太短会不如聊天窗口的影响且记忆存储效果不佳，太长更新记忆会较为耗时。 
    
- 更新记忆库意味着和该bot聊天时需要修改systemPrompt，则需要重建聊天context缓存。
    
- context缓存也可以带来一定的窗口记忆效果（可以理解为缓存下来systemPrompt + 过往聊天messages）
    
- context缓存下的聊天成本平均下来在raw completion的 1/3
# 角色制作流程
## 新建/编辑 botBaseInfo

```
message BotBaseInfo {
  string bot_id = 1;
  string name = 2;
  string gender = 3;
  int32 age = 4;
  string greeting = 5;
  // Bot设定（影响聊天上下文）
  string setting = 6;
  // Bot介绍（侧重App内Bot展示内容、不影响聊天上下文）
  string introduction = 7;
  string appearance = 8;
  repeated string hash_tags = 9;
}

message BotContentController {
  string bot_id = 1;
  bool is_nsfw = 2;
  bool is_copyright = 3;
  // 是否公开到社区
  bool is_public = 4;
  // 是否允许二创
  bool is_allow_recreate = 5;
}

message UpsertBotBaseInfoReq {
  optional string bot_id = 1;
  string name = 2;
  string gender = 3;
  int32 age = 4;
  string greeting = 5;
  string introduction = 6;
  string appearance = 7;
  repeated string hash_tags = 8;
  bool is_nsfw = 9;
  bool is_copy = 10;
  bool is_public = 11;
  bool is_allow_recreate = 12;
}
```

## 编辑聊天相关

```
message BotChatController {
  string bot_id = 1;
  string chat_prompt_template_id = 2;
  map<string, string> chat_boost = 3;
  bool is_support_persona = 4;
  bool is_support_memory = 5;
}

message UpsertBotChatControllerReq {
  string bot_id = 1;
  string chat_prompt_template_id = 2;
  map<string, string> chat_boost = 3;
  bool is_support_persona = 4;
  bool is_support_memory = 5;
}

message ChatPromptTemplate {
  string chat_prompt_id = 1;
  string name = 2;
  string description = 3;
  bool is_nsfw = 4;
  string prompt_template = 5;
  // 约束信息
}

message ChatPromptTemplateListReq {
  string chat_prompt_id = 1;
  string name = 2;
  string description = 3;
  bool is_nsfw = 4;
}
```

- 提交时表单及接口校验 [数据源]与[Template]是否相互约束
    
- nsfw template 仅 nsfw 角色可选
    

## [批量/单个生成图片][上传图片]到bot图片素材库

```
message Picture {
  string url = 1;
  string endpoint_id = 2;
  string input_prompt = 3;
  // -----
}

message BotPictureController {
  string bot_id = 1;
  Picture thumbnail = 2;
  string avatar = 3;
  // repeated Picture photos = 3;
}
```

## 应用图片给bot

## 测试各功能效果

## Bot上线

// AdminControll

## 更新Bot
# 生图Endpoint管理
Endpoint为用户使用某种生图选项的抽象(包含业务信息与逻辑)

其中：

- name:Endpoint的名称，用于标识不同的生图选项
- description:Endpoint的描述，用于说明该生图选项的说明与详解
- NSFW:是否可以生成色情内容，涉及到业务中选项可见性
- nodeInfo:Endpoint关联的Node信息，包含Node的类型、名称、描述等
- System Prompt:如有，当用户选择该Endpoint时，用户输入会经过一层大模型转化

Node为实际提供某种风格生图服务的抽象(例如一个特定画风的API节点 or 一个调试好的ComfyUI工作流)


- ComfyUI节点：
    
    - 在ComfyUI中配置好的一个工作流（CheckPoint、Lora配置、关键Prompt）
        
- Seedream节点：
    
    - 选用Seedream API作为一个生图节点（模型接入点、参数配置、关键Prompt）
        
    
- 生图Endpoint：
    
    - nodeId：对应服务节点ID，依赖此来确定请求specific服务
        
    - name: 标识名称
        
    - description：描述该Endpoint适用的场景
        
    - NSFW：标识是否大尺度生图endpoint，若为true，仅标识了NSFW的Bot可以使用该endpoint
        
    - widelyUse: // 
        
    - sysPrompt：用以处理用户的输入，生图服务使用的前过程
        
    - endpointId: 主键ID
    
![[Pasted image 20251014093333.png]]
## 需求：

### 管理节点：/swagger-ui/index.html

- 节点结构确认与实现方案 P0
    
- 节点创建、编辑接口 P0
    
- 节点测试方案 P0
    
- 节点管理UI P0
    
- 节点测试UI P0
    
- 节点编辑日志记录 P1
    

### 管理Endpoint

- endpoint 结构确认与业务实现 P0
    
- endpoint 创建、编辑接口 P0
    
- endpoint 测试方案 P0
    
- endpoint 管理UI P0
    
- endpoint 测试UI P0
    
- endpoint 编辑日志记录 P1
    

### Endpoint生图实现

- endpoint 业务接入测试 P0
    
- endpoint 接入创建角色流程 P0
    
- 使用endpoint创建角色 -> 生图流程 P0
# 角色聊天内容控制
## Bot 基础信息

Bot在应用内多模块通用属性，例如姓名，性别，简介，外貌等

数据源tag: base

${base.infromation}

${base.name}

## Bot ChatBoost

Bot所具有的聊天prompt需要的额外配置字段，固定内容型，如世界观，聊天发生场景，聊天的语气控制等。

数据源tag: boost

${boost.background}

${boost.chatStyle}

## Bot ChatPluginAbility

该Bot可以具备的增强聊天效果的能力，开关型。例如是否支持Persona、是否支持记忆、好感度系统等

受角色plugin开关字段影响

数据源tag: plugin

比如：

1. 角色创建时，勾选了Persona能力

2. 那么数据源plugin中会提供两个值：isPersona、persona

```
$if<plugin.isPersona>
## Persona

${plugin.persona}

$endif

# Rules
……
……
$if<plugin.isPersona>
- 你的回复应该参照用户的个性设定 [Persona]
$endif
```

## ChatContext

上下文提供的数据源，内容型，不受Bot属性约束，可以供给给chatPrompt直接使用。

数据源tag: context

${context.userSafe}
# bot创建与管理ver 0.1 & 聊天功能测试
快速搭建一个持久化bot基础字段与聊天增强字段的能力用于测试

测试聊天效果 --> 辅助prompt编写 --> 迭代至bot 1.0创建流程

## 核心能力：

### 创建/修改bot：

字段：

- name ( bot名称，多处需用到，聊天的第二人称必须 )
    
- gender （同上）
    
- age （ 增强bot人感属性 ）
    
- greeting （ UI展示需要，对聊天有一定的影响 ）
    
- introduction （ 同上 ）
    
- appearance （ 通用外貌描写， 1.0 生图会取，对聊天有一定影响，如需细致描写加强聊天/生图可在增强字段中增加描述 ）
    
- chatBoost： 非通用bot聊天增强字段，自由配置Map，如有些prompt需要设置，世界观，人物关系网络等等。先存在bot表，方便测试
    
- chatPromptTemplate：先存在bot表，方便测试
    

```
message BotInfo {
  string bot_id = 1;
  string name = 2;
  string gender = 3;
  int32 age = 4;
  string greeting = 5;
  string introduction = 6;
  string appearance = 7;
}
```

```
message BotChatEntity {
  // 未来设计为带枚举type的对象数组
  string chat_prompt_template = 1;
  map<string, string> chat_boost = 2;
}
```

### bot列表：

创建好的bot列表，聊天的入口

```
message BotInfoList {
  repeated BotInfo list = 1;
}
```

### 聊天：

与创建好的bot进行聊天测试

```
message ChatResp {
  int64 time_cost = 1;
  int64 input_tokens = 2;
  int64 output_tokens = 3;
  string content = 4;
}
```
# Task
## 模块职责概览

- 提供标准化的任务事件模型（START/DELTA/END/ERROR/HEARTBEAT），供生产者发布、消费者订阅。
    
- 基于 NATS JetStream 实现可靠消息投递与背压控制，适配 SSE 等长连接场景。
    

## 任务消息模型

- - `type`：枚举 `TaskMessageType`（START, SYNC, DELTA, END, ERROR, HEARTBEAT）。
        
    - `data`：泛型负载，常见为任务 ID、文本增量或 `BaseResp` 错误对象。
        
- `TaskMessage.delta` 当前传输文本片段；如需结构化数据，可扩展 `TaskPayload` 子类型（例如 `ChatTaskDelta`）。
    

## 服务流程

- - `start(UUID id)`：发布任务开始事件。
        
    - `delta(UUID id, String delta)`：推送增量数据（TODO：后续支持结构化 Payload）。
        
    - `finish(UUID id)`：发布任务结束事件。
        
    - `error(UUID id, BusinessException ex)`：推送错误消息（封装为 `BaseResp`）。
        
    - `subscribe(UUID id)`：返回 `Flux<TaskMessage<Object>>`，客户端可通过 SSE/WebFlux 订阅。
        
- 订阅实现细节：
    
    - 使用 `Flux.defer` + `Flux.generate`，为每个订阅懒加载 JetStreamSubscription。
        
    - `nextMessage` 超时 10 秒下发 `HEARTBEAT`，避免连接空闲被断开。
        
    - 收到 `END`/`ERROR` 后完成流并在终结回调中 `unsubscribe`。
        
    - 发生异常时，区分业务异常和其他异常，统一下发 `ERROR` 消息并终止。
        
- 调度策略：
    
    - `subscribe` 运行在 `Schedulers.boundedElastic()`，避免阻塞调用线程。
        

## 基础设施

- - 创建 NATS 连接与 JetStream/JetStreamManagement Bean（基于 `nats.url`）。
        
    - 在应用启动时尝试创建 `TASK` 流，主题前缀为 `task.>`，持久化方式为 `StorageType.File`。
        
    - 未连接成功时记录错误并返回 `null`，调用方需注意判空。
        
- - `/tasks/test/{id}/simulate`：在异步线程中模拟完整生命周期，可设置增量次数/间隔。
        
    - `/tasks/test/{id}/stream`：以 SSE 形式订阅指定任务流，验证 `subscribe` 输出。
        

## 与 Chat 模块的协作

- Chat 模块是 Task 模块的主要生产者：
    
    - 用户发送消息时调用 `TaskService.start` → 流式输出 `delta` → 完成时 `finish`。
        
    - 异常情况使用 `TaskService.error` 将 `BusinessException` 转换为 `BaseResp`，前端可直接解析。
        
- Task 模块对上层业务无感知，也可以服务于生成图片、执行耗时操作等其他任务型场景。
    

## TODO

在数据库里建表，对 task 进行鉴权，确认该 task 用户可以访问
# Chat
# 表设计

```
@Entity
@Table(name = "chat_history")
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class ChatHistoryDO extends AuditableEntity {
  @Id
  private UUID id;
  // session id
  private UUID sid;
  private Integer turnIdx;
  private MessageType type;
  private Sender sender;
  private String content;
  private String extraContent;
}
```

```
@Entity
@Table(name = "chat_info")
@IdClass(ChatInfoId.class)
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatInfoDO {
  @Id
  private UUID bid;
  @Id
  private UUID uid;
  private UUID sid;
  private UUID lastMsgId;
}
```

```
@Entity
@Table(name = "chat_session")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ChatSessionDO {
  @Id
  private UUID id;
  private UUID bid;
  private UUID uid;
  private Integer turnCount;
}
```

## History

准备直接放到postgres，具体能承受多少数据量待测试，

看一些文章介绍，如果查询逻辑不复杂是可以支持上亿级别的数据

## Session

用于标记用户和bot的一个聊天session，方便拓展以及后续切换history存储使用

以及回退和重启

## Info

用来存储当前用户的聊天列表信息

包括上次聊天内容和上传聊天时间

## 模块职责概览

- 对外提供聊天相关 API：会话列表、历史记录、消息发送与流式响应订阅。
    
- 管理用户与 Bot 的会话上下文、消息持久化、Prompt 渲染与模型调用。
    
- 与 Task 模块协作，将模型生成过程映射为可订阅的任务流。
    

## 控制层

- - `GET /chat/info`：返回用户已有 Bot 会话列表，分页入参由 `Pageable` 驱动。
        
    - `GET /chat/{bid}/history`：按会话倒序查询聊天历史，需校验 Bot 是否有效。
        
    - `POST /chat/completion`：发送用户消息并以 SSE (`MediaType.TEXT_EVENT_STREAM_VALUE`) 返回 `Flux<TaskMessage<Object>>`。
        
- 所有接口封装在 `BaseResp` 中返回，便于前端统一处理成功/异常。
    

## 服务层流程

- `ChatService.listChatInfo`（`src/main/java/tech/ejoy/mimo/service/ChatService.java`）：
    
    - 通过 `ChatInfoRepo` 查询 `chat_info`，合并 `BotBaseRepo` 的 Bot 信息与 `ChatMessageRepo` 的最后一条消息。
        
    - 结果包装为 `Paged<ChatInfoDTO>`，最终转换为 VO 返回。
        
- `ChatService.queryChatHistory`：
    
    - 校验 `bot_base` 是否存在。
        
    - 若无 `ChatInfoDO` 或未创建会话，则返回空分页。
        
    - 否则根据 `sid` 在 `chat_message` 表中按 `index` 倒序分页。
        
- `ChatService.completion`：
    
    1. 兜底获取 `ChatSessionDO`，不存在时通过 `createSession` 新建会话并写入 Bot 问候语。
        
    2. 生成用户消息 (`ChatMessageDO`) 并持久化，维护历史消息。
        
    3. 读取 `ChatBoostDO`/`ChatPromptTemplateDO` 组合系统 Prompt，交由 `RenderPromptService` 渲染。
        
    4. 调用 `StreamingChatModel` (`skyLarkProStreaming`) 发起流式请求，同时生成任务 ID 调用 `TaskService.start`。
        
    5. 在线程池 (`ThreadPoolConfig.executor`) 中消费模型输出，每个分片调用 `TaskService.delta` 推送给订阅端，累积完整答复。
        
    6. 将助手回复写入 `chat_message`，更新 `chat_session.count` 与 `chat_info.lastMsgId`，最后触发 `TaskService.finish`；异常时 `TaskService.error`。
        

## TODO

1. 增加相关的锁，使用户每次只能进行一个聊天
    
2. 聊天结果解析
    
    1. 需要定制一个流式json解析
# Image
## Image

大部分内容采用跟console同样的设计

generate photo时，从 bot 的封面取出默认的endpoint，然后将bot 封面和input，以及endpoint 作为参数生图

### 接口设计

```
@Slf4j
@RestController
@RequestMapping("/image")
@Tag(name = "Image", description = "")
public class ImageController {

  @PostMapping("/generate/photo")
  @Operation(summary = "Generate photo", description = "Generate a photo based on the request body.")
  public BaseResp<GeneratePhotoResp> generatePhoto(@RequestBody GeneratePhotoReq body) {
    throw Exceptions.todo();
  }

  @PostMapping(value = "/upload", consumes = "multipart/form-data")
  public BaseResp<UploadImageResp> uploadImage(@UserId UUID uid, @RequestParam MultipartFile file,
      @RequestParam @NotNull ImageType type) {
    throw Exceptions.todo();
  }
}
```
# bot点赞
# 需求实现必要说明

- 接口 ：点赞 (like)、取消点赞 (unlike) 以及获取Bot详情 (detail)
    
- 点赞与用户是多对多关系，所以要建一张关联表 user_bot_like
    
- bot点赞详情需要查询统计，同一个bot下的user数量
    

# 难点说明

## 点赞统计（BotStats）

字段： 点赞数like_count 对话数chat_count

方案一

项目初期或点赞量不大的情况，SELECT COUNT(*)。

优点：实现简单

缺点：数据量大的话，查询效率低

方案二( √ )

新建bot_stats 统计表有bid like 和 chat 字段。每次执行点赞/取消点赞操作时，通过事务同时更新like 字段

新建bot_stats 统计表有bid like 和 chat 字段,消息队列同步

优点：查询效率高

缺点：增加写入操作的复杂度，并需保证数据一致性。

注意：like_count chat_count的统计，通过消息队列来实现，定期更新数据记录

## 数据持久化与实时性

- 实时性：用户点完赞后，希望立即看到点赞数加一，并且点赞数是热点数据，查询多，这里可以用redis缓存
    
- chat_count持久化：使用消息队列预先存储事件消息，定时消费（波谷）
    

# 库表设计

表名: user_bot_like 说明: 用户-Bot点赞关联表，记录哪个用户 (uid) 点赞了哪个Bot (bid)。 表结构定义:

```
CREATE TABLE user_bot_like (
    uid UUID NOT NULL,
    bid UUID NOT NULL,
    
    created_at TIMESTAMP(6),
    updated_at TIMESTAMP(6),
    deleted_at TIMESTAMP(6),
    
    -- 设置 uid 和 bid 为联合主键，确保一个用户对一个Bot只能点赞一次
    PRIMARY KEY (uid, bid)
);
```

表名: bot_stats

说明: 存储与Bot相关的统计数据，以优化查询性能。 表结构定义:

```
CREATE TABLE bot_stats (
    bid UUID NOT NULL,

    like_count BIGINT NOT NULL DEFAULT 0,
    chat_count BIGINT NOT NULL DEFAULT 0,
    
    created_at TIMESTAMP(6) ,
    updated_at TIMESTAMP(6),
    
    PRIMARY KEY (bid),
    
    -- 添加外键约束
    CONSTRAINT fk_bot_stats_bid FOREIGN KEY (bid) REFERENCES bot(id) ON DELETE CASCADE;
    

```

# 接口设计

```
@PostMapping("/{bid}/like")
  @Operation(summary = "Like bot", description = "Mark the bot as liked by current user (idempotent)")
  @WithSpan
  public BaseResp<Void> likeBot(@UserId @SpanAttribute UUID uid,
      @Parameter(description = "Bot ID") @PathVariable @SpanAttribute UUID bid) {
    throw Exceptions.todo();
  }

  @PostMapping("/{bid}/unlike")
  @Operation(summary = "Unlike bot", description = "Remove like from the bot for current user (idempotent)")
  @WithSpan
  public BaseResp<Void> unlikeBot(@UserId @SpanAttribute UUID uid,
      @Parameter(description = "Bot ID") @PathVariable @SpanAttribute UUID bid) {
    throw Exceptions.todo();
  }

  @GetMapping("/{bid}/detail")
  @Operation(summary = "Get bot details", description = "Return bot base info and stats")
  @WithSpan
  public BaseResp<GetBotDetailResp> detail(@UserId @SpanAttribute UUID uid,
      @Parameter(description = "Bot ID") @PathVariable @SpanAttribute UUID bid) {
    throw Exceptions.todo();
  }



public class GetBotDetailResp extends BotDetailVO {

}

public class BotDetailVO {
  private BotBaseInfoVO base;
  private BotStatsVO stats;
  private BotUserDataVO userData;
}
```

# 复杂流程说明

## detail 接口处理流程：

1. 接收请求: 控制器接收到路径参数 bid 和从用户身份认证中获取的 uid。
    
2. 数据查询: 为了优化响应时间，后端应发起以下三个独立的数据库查询：
    
    ```
    public class BotDetailVO {
      private BotBaseInfoVO base;
      private BotStatsVO stats;
      private BotUserDataVO userData;
    }
    ```
    
    -  GetBotDetailResp DTO继承BotDetailVO
        
    
    - 查询1 (Bot基础信息): 根据 bid，联结 bot_base表，获取Bot的基础信息。若Bot不存在，返回。
        
    - 查询2 (总点赞数): 在bot_stats 中查询
        
    - 查询3 (当前用户点赞状态):
        
        - 由于只需要看当前bot是否点赞被当前用户赞过，而不是查看所有该用户赞过的bot，在 user_bot_like 关联表中，执行 SELECT EXISTS (SELECT 1 FROM user_bot_like WHERE uid = ? AND bid = ?) 查询。此查询比 COUNT 更高效，因为它在找到一条匹配记录后会立刻返回 true。
            
        - 或者 加上注解开发
            
3. 数据汇总: 等待所有查询完成后，将获取到的三部分数据组装成 GetBotDetailResp DTO对象。
    
4. 返回响应: 将填充好的 DTO 对象序列化为 JSON 并返回给客户端。
    

## like接口处理流程（先写数据库再写缓存）

1. 操作 PostgreSQL: 在 user_bot_like 表中 INSERT 一条记录。
    
2. 操作 Redis: 只有在第1步 INSERT 成功后，才执行此步。 调用 Redis 的 INCR 命令，对相应的 like_count 键（例如 bot:stats:{bid}:likes）执行原子加一操作。INCR 命令本身是原子的，不会有并发问题。
    

mq中添加一条消息

### PostgreSQL 成功，写 Redis 失败了怎么办？（待定开发，因为点赞不是强一致性业务）

- 定期校验
    
- 消息队列
    

## unlike接口处理（与like接口类似）

# 需要的额外操作

每天定时或者懒加载同步redis数据到postgres

使用消息队列预先存储事件消息，定时消费（波谷）
# User
# 表设计

```
message User {
	UUID id = 1;
	string username = 2;
	string nickname = 9;
	string password = 3;
	int64 age = 4;
	bool audit = 5;
	string avatar = 6;
	string country = 7;
	bool gender = 8;
	bool nsfw = 13;
	Timestamp created_at = 10;
	Timestamp updated_at = 11;
	Timestamp deleted_at = 12;
}
```

# 服务端设计

### 使用非对称加密签名jwt

private key 签名 public key 验签

### 双token机制

access_token 有效期短，加入ip验证， 当ip不符或者过期时，access_token 则无效，需要使用 refresh_token 重新获取

refresh_token 记录到数据库中，需要支持revoke，

# 用户接口设计（TODO）

```
@Slf4j
@RestController
@RequestMapping("/user")
@Tag(name = "User", description = "User account and authentication APIs")
public class UserController {

  @PostMapping("/sign-up")
  @Operation(summary = "Sign up", description = "Register a new account and receive access/refresh tokens.")
  public BaseResp<SignUpResp> signUp(@RequestBody SignUpReq body) {
    // TODO: wait for prd, or do a simple implementation
    throw Exceptions.todo();
  }

  @PostMapping("/sign-in")
  @Operation(summary = "Sign in", description = "Authenticate and receive access/refresh tokens.")
  public BaseResp<SignInResp> signIn(@RequestBody SignInReq body) {
    // TODO: wait for prd
    throw Exceptions.todo();
  }

  @PostMapping("/sign-out")
  @Operation(summary = "Sign out", description = "Invalidate the current user session.")
  public BaseResp<Void> signOut() {
    // TODO: wait for prd
    throw Exceptions.todo();
  }

  @PostMapping("/refresh-token")
  @Operation(summary = "Refresh access token", description = "Exchange a valid refresh token for a new access token.")
  public BaseResp<RefreshTokenResp> refreshToken(@RequestBody RefreshTokenReq body) {
    throw Exceptions.todo();
  }

  @GetMapping("/info")
  @Operation(summary = "Get current user info", description = "Return basic profile for the authenticated user.")
  public BaseResp<UserInfoResp> info(@UserId UUID uid) {
    throw Exceptions.todo();
  }

  @PostMapping("/update-avatar")
  @Operation(summary = "Update user avatar", description = "Update user avatar for the authenticated user.")
  public BaseResp<Void> updateAvatar(@UserId UUID uid, @RequestBody UpdateAvatarReq body) {
    throw Exceptions.todo();
  }
}
```

# 登录

## 设备登录

通常用来做自动登录，或游客登录

较为简单，deviceId 一般取adid，通常是不会变的

输入：deviceId

## 三方登录

后续如果绑定discord的话，我们可以方便的建立社区

通过第三方账号进行登录

- apple（开发者账号和市场发行一致）
    
- google（开发者账号和市场发行一致）
    
- fb（开发者账号独立建设）
    
- x （开发者账号独立建设）
    
- discord （可能需要工程建设）
    
- …
    

## 邮箱登录

工程建设较为简单

## 短信登录

由于海外短信公司内没基建，调研成本比较高

## 登录的问题

1. 设备登录定义为游客登录还是正式用户
    
2. 多账号关联 uid 一致性保证
    
3. ios 和安卓登录绑定到一个账号是否合规，需要产品调研
    
4. 是否同时支持多个设备登录
    
5. …
    

# 用户体系

1. 确定用户唯一标识符
    
    1. 查找用户
        
    2. 用户社区发言时的 name 是标识符还是 nickname
        
    3. 标识符是否可以更改
        
2. 用户 1.0 需要存哪些信息


#  ficstory
# 第一部分：智能翻译平台，

旨在提升编辑效率

## 1、标记文章术语

不同类型的术语除能准确标注外，还需要分辨术语类型

对于人物类型术语，需要增加备注，例如：男主，男主父亲，女主朋友，女二等

中文小说和英文小说均需要标注术语

|   |   |   |
|---|---|---|
|术语类型|举例|语言|
|人名/称谓|主角、配角的名字、昵称、代号等，如：李小花，小花，小龙女，孙悟空，牛魔王，神秘人X…|中/英|
|家族名|相同姓氏的一家人，如：李氏家族，张氏...|中/英|
|地理名|大洲，国家，省，市，县，区，山川湖海等地理名需替换为虚拟名称，不能使用真实地名|中/英|
|机构名|单位、集团、企业、学校、政府机构、门派帮派等组织机构，如：药监局、中情局、李氏集团、盛阳集团...|中/英|
|职务|文中出现的角色工作中的titles，如：医生、律师、警察、厨师、老师、总裁、尚书、特助、首长、太子...|中/英|
|品牌|文中出现的常见的品牌名称，如：玛莎拉蒂，微信，LV，奔驰...|中/英|
|货币|文中使用的真实或虚拟货币，如：元、美元、灵石...|中|
|度量衡|文中出现的用于度量长度、重量等单位，如：米、摄氏度、千克...|中|
|食物|文中出现的食物，如：北京烤鸭、面条、包子、披萨...|中|
|影音读物|文中出现的现实或虚拟的电影电视、音乐、书籍游戏等作品，如：哈利波特、爱丽丝漫游仙境、王者荣耀...|中|
|风俗节日|文中出现的节日、风俗习惯等，如：新年、中元节、清明节、红包、拜年、吃粽子...|中|
|修仙练级|如：九阳神功、如来神掌、九阴真经、元婴、筑基、五行、八卦...|中|
|医学医药|如：中医、推拿、针灸、把脉、灵药、仙丹、神药、炼丹、炼丹炉...|中|
|法律条例|文中出现的法律、刑罚、惩罚等，如：宪法、契约、婚约、割鼻、砍头、无期徒刑...|中|
|珍奇物品|文中出现的古董、古玩、名画等，如：琉璃樽，大卫雕塑，蒙娜丽莎画...|中|
|人物描写|中文语境中的人物外貌，人物穿着等，如：黑眼睛，黑头发，雪白的肌肤，白皙的脖子，肌肤白的发光，旗袍，中山装，汉服等|中|
|关系称呼|中文色彩浓厚的称呼，亲家公，亲家母，叔叔，婶婶，姑姑，舅舅，阿姨，哥哥，姐姐，弟弟，妹妹，爷爷，奶奶，爸爸，妈妈等|中|

## 2、俗语单独处理，提前标注，翻译后进入通用术语库

|   |   |   |
|---|---|---|
|中文俗语|成语、谚语、俗语、网络热梗等<br><br>如：世家子弟，十八代祖宗，瘦死的骆驼比马大，屁都不敢放一个，恨铁不成钢等|中|

收集整理中文俗语库，丢给AI前标注待翻译文字内容。

待编辑将俗语内容翻译后，自动加至通用术语库，除自动标注外还可以帮助编辑自动替换

  

ps：AI标注，自动标注，自动替换各自使用不同的颜色

  

## 3、人名/称呼/称谓ai后处理

将ai处理结果中的人物名字单独拿出来，自行按规则标注

- 姓：X总，X经理，X哥，X爷，X爷爷，X奶奶，X老夫人，X夫人，X老爷子，X嫂，X氏，X爸，X妈，X先生，X小姐，X姐，X叔，X婶（姓的适配变体规则可在书籍库手动增删查改）
    
- 昵称：三/四字名字取后两字，二/三/四字名字取后一字叠词/小+最后一个字/阿+最后一个字
    

  

将ai标注中同一个人名，但大小写拼写不同的术语视为同一个术语

  

## 4、无需本地化后处理

建立无需本地化术语库，编辑可手动进行增删查改

ai术语提取完成后，过滤掉无需本地化处理的术语，再进行标注

  

## 5、给书籍添加分类/标签

  

使用原书提交给GPT打标签，无论书籍本身的语言是什么均生成英语标签。注意一次性token输入性价比。暂定输出30个备选英文标签

  

标签后处理：AI打标签之后，如果该标签是系统已有的，则根据https://console.ficstories.com/book/category的供需比例排序（越小供需矛盾越突出，升序排列）。如果该标签系统内没有，则新增一个标签，并同时发送本地化告警信息至告警群

供需比计算方式：书籍数量/标签点击量

  

将书籍库书籍自动生成的标签建议同步至控制台，编辑最终手动确认修改后生效。

后续实现待使用后补充

================================================================

1、AI标签只上传15个，原文标签待编辑确认后决定是否上传控制台

2、AI标签添加至控制台时，应同步新增标签分类Style，Plot，Identity，Character

3、AI标签如果系统没有，则统一新增未生效状态，直至编辑将此未生效标签选定为某本书的最终确认标签后，将未生效状态修改为生效

4、标签管理页面新增标签状态筛选，新增操作人，新增操作生效/不生效，原有非AI标签操作人统一设置为system，状态设为生效

5、书籍标签选择页面供编辑筛选的标签，只显示生效标签和这本书的AI推荐标签

6、相似标签去除，将AI标签系统原有标签进行相似度对比，相似度达到某个阈值的自动去除，不予添加，同时把原有系统标签作为该本书的AI选中标签

  

  



## 8、GPT使用情况汇总

按照时间段可筛选各个模块gpt使用token情况

AI术语标注

手动点击重新翻译

自动翻译

AI打标签

  

对于非系统任务

统计各个编辑的重复次数

  

使用记录

时间，操作人，输入/输出 使用类型，调用模型，单价，价格，书籍id，章节，输入内容/输出内容，状态（成功/失败）

  
