#### 1. 为什么要分库分表？

当处理日志，消息等这些海量数据的时候，单一数据库会遇到以下问题：

- IO瓶颈： 大量的读写请求集中在单个数据库，磁盘IO、网络IO无法承受
    
- CPU瓶颈： 复杂的SQL查询、数据计算消耗大量CPU资源，导致性能下降
    
- 连接数瓶颈： 应用服务器的数据库连接数是有限的，单个数据库能支撑的连接数同样有限
    
- 存储瓶颈： 单机磁盘容量有限，无法存放持续增长的海量数据
    

分库分表（Sharding） 就是为了解决上述问题而产生的数据库架构优化方案。其核心思想是：*将存放在一个数据库中的大量数据，按照特定的规则，分布到多个数据库（主机）中，从而达到分散单一数据库负载的目的

#### 2. 什么是分库？什么是分表？

- 分表（Table Sharding）： 将一张大表的数据，按照某种规则（如ID取模、时间范围等），拆分到多个结构完全相同的表中。例如，将 `user` 表拆分为 `user_0`, `user_1`, ... , `user_9` 共10张表。分表后，所有操作数据的SQL语句都必须包含分表的规则（即分片键，如UserID），否则就需要扫描所有表，效率极低
    
- 分库（Database Sharding）： 将一个数据库中的数据，按照某种规则，拆分到多个数据库中。每个库可以放在不同的服务器上。解决数据库整体负载过高的问题。例如，将 `db` 库拆分为 `db_0`, `db_1` 两个库，分别部署在服务器A和服务器B上。 分库后，跨库的关联查询（Join）、事务处理会变得非常复杂和困难
    

一般情况下，单表数据量到达千万级别，就可以考虑分库分表了，通常是先分库，在库内再分表，从而同时解决流量和单表数据量过大的问题

#### 3. 分库分表的常见策略

分表：

- 水平拆分（Horizontal Sharding）： 这是最常用的方式。将同一张表中的数据按行拆分到不同的表/库中。所有分片的表结构完全一致
    
    - 取模分片（Hash）： 根据某个字段（如用户ID）的Hash值进行取模，决定数据落在哪个分片。优点：数据分布均匀。缺点：扩容（如从2库扩到3库）时，数据迁移量大
        
    - 范围分片（Range）： 根据某个字段的范围（如创建时间、ID区间）进行分片。优点：易于扩容。缺点：可能造成数据分布不均（热点数据）
        
    - 地理分片（Geographic）： 根据用户所在地等地理位置信息分片
        
    - 一致性Hash： 为了解决取模分片扩容难的问题，尽可能减少数据迁移
        
- 垂直拆分（Vertical Sharding）： 将一张宽表按列拆分成多个表（通常是将不常用的字段或大字段拆出去）。这种方式更常见于单库内的表设计优化，而非分布式场景下的核心手段。 混合拆分：
    

分库： 1）[垂直分库](https://zhida.zhihu.com/search?content_id=254076547&content_type=Article&match_order=1&q=%E5%9E%82%E7%9B%B4%E5%88%86%E5%BA%93&zhida_source=entity)：按照业务类型对表进行分类，将业务相关的一类表放在一个库中。这种方式很大程度上取决于业务的划分，专库专用，能在一定程度上提升数据库性能，但并未从根本上解决单表数据量过大的问题。

2）[水平分库](https://zhida.zhihu.com/search?content_id=254076547&content_type=Article&match_order=1&q=%E6%B0%B4%E5%B9%B3%E5%88%86%E5%BA%93&zhida_source=entity)：把同一个表按照规则拆分到不同的数据库中，每个库可以位于不同的服务器上，以此实现水平扩展。

#### 4.原则：

1.优先MySQL调优，能不分就不分

数据量能稳定在千万级，近几年不会到达亿级，其实是不用着急拆的，先尝试MySQL调优，优化读写性能。只有在MySQL调优已经无法解决慢查询问题时，才可以考虑分库分表。

2.分片数量尽量少

分片尽量均匀分布在多个 DataHost 上，因为一个查询 SQL 跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量。

3.不要一个事务里跨越多个分片查询

尽量不要在一个事务中的 SQL 跨越多个分片，分布式事务一直是个不好处理的问题。

# Sharding sphere

#### 1.ShardingSphere-JDBC 的核心概念

轻量级 Java 框架，在 Java 的 JDBC 层提供额外服务。它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署，性能很高。它通过解析、改写、路由、执行、归并等流程，将一条SQL语句智能地路由到正确的分片数据库和分片表中执行

- 逻辑表（Logic Table）： 水平拆分的数据库表的逻辑名称。例如 `t_user`。
    
- 真实表（Actual Table）： 在数据库中真实存在的物理表。例如 `t_user_0`, `t_user_1`。
    
- 数据节点（Data Node）： 由数据源名称和数据表组成。例如 `ds0.t_user_0`。
    
- 分片键（Sharding Key）： 用于分片的数据库字段，是进行水平分片的关键。例如 `user_id` 字段。
    
- 分片算法（Sharding Algorithm）： 根据分片键的值，计算出数据应该存放在哪个位置的算法。例如 `user_id % 4`。
    

#### 2. 快速入门示例

场景： 我们将用户表 `t_order` 进行分库分表

- 分库： 分为2个库，`ds0` 和 `ds1`。规则：根据 `order_id` 取模，`order_id % 2`
    
- 分表： 每个库中，`t_order` 表分为2张表，`t_order_0` 和 `t_order_1`。规则：根据 `user_id` 取模，`user_id % 2`
    

这意味着，最终数据会分布在4张物理表上： `ds0.t_order_0`, `ds0.t_order_1`, `ds1.t_order_0`, `ds1.t_order_1`

Spring Boot + ShardingSphere-JDBC 的 YAML 配置：

```
spring:
  shardingsphere:
    datasource:
      names: ds0, ds1 # 定义两个数据源
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/ds0
        username: root
        password: password
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/ds1
        username: root
        password: password

    rules:
      sharding:
        tables:
          t_order: # 逻辑表名
            actual-data-nodes: ds$->{0..1}.t_order_$->{0..1} # 指定真实数据节点，ds0.t_order_0, ds0.t_order_1, ds1.t_order_0, ds1.t_order_1
            database-strategy: # 分库策略
              standard:
                sharding-column: order_id # 分库的片键
                sharding-algorithm-name: db-inline # 分库算法名
            table-strategy: # 分表策略
              standard:
                sharding-column: user_id # 分表的片键
                sharding-algorithm-name: table-inline # 分表算法名
        sharding-algorithms: # 定义分片算法
          db-inline:
            type: INLINE
            props:
              algorithm-expression: ds$->{order_id % 2} # 分库算法表达式
          table-inline:
            type: INLINE
            props:
              algorithm-expression: t_order_$->{user_id % 2} # 分表算法表达式
        props:
          sql-show: true # 在日志中打印实际执行的SQL，用于调试
```

当执行时：

```
INSERT INTO t_order (order_id, user_id, amount) VALUES (123, 456, 100.00);
```

ShardingSphere-JDBC 会：

1. 解析： 解析SQL，提取出分片键 `order_id=123` 和 `user_id=456`
    
2. 路由：
    
    - 计算库：`123 % 2 = 1` -> 路由到 `ds1`
        
    - 计算表：`456 % 2 = 0` -> 路由到 `t_order_0`
        
3. 改写： 将原始SQL改写为：`INSERT INTO ds1.t_order_0 (order_id, user_id, amount) VALUES (123, 456, 100.00);`
    
4. 执行： 通过数据源 `ds1` 执行改写后的SQL
    
5. 归并： 如果是查询，可能从多个节点获取数据，然后聚合成一个结果集返回给客户端
    

参考：[https://blog.csdn.net/qq_40991313/article/details/133797658](https://blog.csdn.net/qq_40991313/article/details/133797658)

[https://zhuanlan.zhihu.com/p/25271876132](https://zhuanlan.zhihu.com/p/25271876132)

[https://www.cnblogs.com/shanren/articles/18456355](https://www.cnblogs.com/shanren/articles/18456355)