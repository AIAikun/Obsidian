# count(`*`) 和 count(1) 有什么区别？哪个性能最好？
![[Pasted image 20250313210423.png]]
## 哪种 count 性能最好？
![[Pasted image 20250313210453.png]]
### count() 是什么？
count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是**统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个**。
假设 count() 函数的参数是字段名，如下：
```sql
select count(name) from t_order;
```
这条语句是统计「t_order 表中，name 字段不为 NULL 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。
再来假设 count() 函数的参数是数字 1 这个表达式，如下：
```sql
select count(1) from t_order;
```
这条语句是统计「t_order 表中，1 这个表达式不为 NULL 的记录」有多少个。
1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t_order 表中有多少个记录。
### count(主键字段) 执行过程是怎样的？
在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。
server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。
用下面这条语句作为例子：
```sql
//id 为主键值
select count(id) from t_order;
```
如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。
![[Pasted image 20250313213157.png]]
但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。
![[Pasted image 20250313213225.png]]
这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。
MySQL 会对 count(`*`) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用 key_len 最小的二级索引进行扫描。
### count(1) 执行过程是怎样的？
用下面这条语句作为例子：
```sql
select count(1) from t_order;
```
如果表里只有主键索引，没有二级索引时。
![[Pasted image 20250313213424.png]]
那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，**但是不会读取记录中的任何字段的值**，因为 count 函数的参数是 1，不是字段。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。
可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。
但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。
![[Pasted image 20250313213540.png]]
### count(`*`) 执行过程是怎样的？
**count(`*`) 其实等于 count(`0`)**，也就是说，当你使用 count(`*`)  时，MySQL 会将 `*` 参数转化为参数 0 来处理。
![[Pasted image 20250313220317.png]]
**count(\*) 执行过程跟 count(1) 执行过程基本一样的**
### count(字段) 执行过程是怎样的？
用下面的语句作为例子：
```sql
// name不是索引，普通字段
select count(name) from t_order;
```
对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。
![[Pasted image 20250313221107.png]]
## 为什么要通过遍历的方式来计数？

## 如何优化  count(`*`)？
如果对一张大表经常用 count(`*`) 来做统计，其实是很不好的，每次count(`*`)都会花费很长时间。
### 第一种，近似值
如果你的业务对于统计个数不需要很精确，可以使用 show table status 或者 explain 命令来表进行估算。执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是  explain 命令对表 t_order 记录的估算值。
![[Pasted image 20250313221700.png]]
### 第二种，额外表保存计数值
如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。
当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。
