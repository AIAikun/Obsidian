# 索引失效有哪些
![[Pasted image 20250312180615.png]]
## 索引存储结构长什么样？
MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构，
## 对索引使用左或者左右模糊匹配
当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。
比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type=ALL 就代表了全表扫描，而没有走索引。
```sql
// name 字段为二级索引
select * from t_user where name like '%林';
```
![[Pasted image 20250312202140.png]]
如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type=range 表示走索引扫描，key=index_name 看到实际走了 index_name 索引：
```sql
// name 字段为二级索引
select * from t_user where name like '林%';
```
![[Pasted image 20250312202209.png]]
> 为什么 like 关键字左或者左右模糊匹配无法走索引呢？

**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**
## 对索引使用函数
如果查询条件中对索引字段使用函数，就会导致索引失效。
比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：
```sql
// name 为二级索引
select * from t_user where length(name)=6;
```
![[Pasted image 20250312202700.png]]
> 为什么对索引使用函数，就无法走索引了呢？

因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。
不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。
通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。
```sql
alter table t_user add key idx_name_length ((length(name)));
```
然后我再用下面这条查询语句，这时候就会走索引了。![[Pasted image 20250312202906.png]]
## 对索引进行表达式计算
在查询条件中对索引进行表达式计算，也是无法走索引的。
下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：
```sql
explain select * from t_user where id + 1 = 10;
```
![[Pasted image 20250312203015.png]]
但是，如果把查询语句的条件改成 where id  = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。
![[Pasted image 20250312203238.png]]
> 为什么对索引进行表达式计算，就无法走索引了呢？

因为索引保存的是索引字段的原始值，而不是表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。
## 对索引隐式类型转换
如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。
我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。
![[Pasted image 20250312204913.png]]
在条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。
```sql
select * from t_user where phone = 1300000001;
```
![[Pasted image 20250312205023.png]]
如果索引字段是整型类型，查询条件中的输入参数即使字符串，还是可以走索引扫描。
```sql
 explain select * from t_user where id = '1';
```
![[Pasted image 20250312205129.png]]
> 为什么第一个例子会导致索引失效，而第二例子不会呢？

 **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。
 这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：
```sql
select * from t_user where CAST(phone AS signed int) = 1300000001;
```
可以看到，**CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的**。
例子二中的查询语句，我跟大家说了是会走索引扫描：
```sql
//例子二的查询语句
select * from t_user where id = "1";
```
这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：
```sql
select * from t_user where id = CAST("1" AS signed int);
```
可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。
## 联合索引非最左匹配
联合索引要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。
有一个比较特殊的查询条件：where a = 1 and c = 3，符合最左匹配吗？
MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，然后再比对 c 字段的值。
从 MySQL 5.6 之后，有一个**索引下推功能**，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
大概原理是：截断的字段会被下推到存储引擎层进行条件判断（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。
比如下面这条 where a = 1 and c = 0 语句，我们可以从执行计划中的 Extra=Using index condition 使用了索引下推功能。
![[Pasted image 20250313090650.png]]
## WHERE 子句中的 OR
在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。
```sql
select * from t_user where id = 1 or age = 18;
```
![[Pasted image 20250313090834.png]]
这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
要解决办法很简单，将 age 字段设置为索引即可。