UUID 和自增主键 ID 是常用于[数据库](https://cloud.tencent.com/product/tencentdb-catalog?from_column=20065&from=20065)主键的两种方式，各自具有独特的优缺点。
UUID 是一个由 128 位组成的全局唯一标识符，通常以字符串形式表示。它可以通过不同的算法生成，例如基于随机数的完全随机的 UUID（version 4）和基于时间戳的有序 UUID 版本（version 7) 等。
# 自增主键
在 [MySQL](https://cloud.tencent.com/product/cdb?from_column=20065&from=20065) 中，可以通过设置 AUTO_INCREMENT 属性实现 ID 的自增长，通常用于作为主键 ID。
优势：
- **存储空间节省**：ID 为数字，占用的位数比 UUID 小得多，因此在存储空间上更加节省。
- **查询效率高**：ID 递增，利于 B+Tree 索引的查询效率提高。
- **方便展示**：ID 较短，可读性高。
- **分页方便**：ID 连续自增，有利于解决深度分页问题。
劣势：
- **分库分表困难并不适用于分布式系统**：自增 ID 只在单库内保证唯一性。在分库分表时，无法依赖单一表的自增主键，可能导致冲突问题。在分布式系统中，不同的主机可能会生成相同的数字，这使得它无法用作唯一标识符。
- **可预测性**：由于 ID 是顺序自增的，因此具有一定可预测性，存在一定的安全风险。
- **可能用尽**：自增 ID 可能是 int、bigint 等，但它们都有范围限制，可能会用尽。
- **性能问题**：在[数据迁移](https://cloud.tencent.com/product/datainlong?from_column=20065&from=20065)期间，如果使用自增主键，数据库可能会产生额外的性能开销。这可能是由于重新计算主键值或更新相关索引所致。这可能会导致数据迁移过程变慢。分布式数据库中快速大量插入数据时计算自增ID可能会是性能瓶颈，导致性能下降。此外，当使用INSERT语句插入一条新记录时，**MySQL会自动为自增字段加锁**，防止其他并发的插入操作同时获取相同的自增值。 这个锁是在内部实现的，不需要用户手动创建或管理。 自增锁确保了插入记录的唯一性和正确性，避免了并发插入产生冲突。 但同时也会带来一些性能上的影响，因为并发插入操作需要等待锁的释放。 因此，在高并发的场景下，可能需要考虑使用其他方案来避免自增锁成为瓶颈。
# UUIDv4
UUID v4通过完全随机或伪随机数生成器生成，确保了其高度的唯一性。
优势：
 - **低碰撞概率**：它极不可能出现重复，这对于在不同环境中需要唯一标识的系统非常有用。例如，在系统之间迁移数据时，冲突的可能性仅仅是理论上的。
 - **无状态且可即时生成，适合分布式系统**：它可以在不依赖任何外部状态的情况下生成，这对于各种应用程序都很方便。UUID非常适合分布式数据库和系统，可以在服务器上独立生成。
- **具有安全性**：恶意用户很难猜出ID，提供了一定程度的安全性。
劣势：
- **可读性差**：UUID是复杂的字符和数字字符串，长度较长，增加存储。
- **索引和数据碎片化**：UUIDv4会使索引和数据碎片化，从而影响数据库效率，新生成的UUID v4可能在排序上位于旧UUID v4之前，这与聚集索引的有序性要求不符，因此需要进行页面的重新排序或拆分。
- **查询效率低**：InnoDB 将表的行存储在主键的 [b-tree](https://zhida.zhihu.com/search?content_id=109956286&content_type=Article&match_order=1&q=b-tree&zhida_source=entity)（[聚簇索引](https://zhida.zhihu.com/search?content_id=109956286&content_type=Article&match_order=1&q=%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95&zhida_source=entity)）中。聚簇索引通过主键自动对行进行排序。当插入具有随机主键值的新数据时，InnoDB 必须找到该行所属的页面，如果尚不存在该页面，则将其加载到[缓冲池](https://zhida.zhihu.com/search?content_id=109956286&content_type=Article&match_order=1&q=%E7%BC%93%E5%86%B2%E6%B1%A0&zhida_source=entity)中，插入该行，然后最终将页面刷新回 磁盘。如果使用纯随机值和大表，则所有 b-tree 的叶子页都易于接收新行，没有热页。不按主键顺序插入的行会导致页面拆分，从而导致较低的填充系数。对于比缓冲池大得多的表，插入很可能需要从磁盘读取表页。缓冲池中已插入新行的页面将变为脏页。在需要刷新到磁盘之前，该页面接收第二行的几率非常低。在大多数情况下，每次插入都会导致两次 IOP（一读一写）。第一个主要是对 IOP 速率的影响，它是可伸缩性的主要限制因素。此外，对于聚集索引，辅助索引将主键值用作指针。主键 b-tree 的叶子来存储行，而二级索引 b-tree 的叶子来存储主键值。导致索引查询效率降低。并且较大的 UUID 大小会导致查询性能降低，因为增加的记录大小会导致每个数据库页存储的记录减少，从而导致更多的 I/O 操作并降低整体性能。
# UUIDv7
UUID v7同样是一个128位的标识符，格式遵循8-4-4-4-12的十六进制表示。UUID v7的创新之处在于其时间排序特性，它在前48位中嵌入了以毫秒为单位的Unix时间戳。UUID v7的格式中，前6位定义了版本号和变体号，剩余74位通过随机生成确保唯一性。
与UUID相比优势：
- UUID v7由于其基于时间戳的生成机制，具有内在的有序性。这意味着UUID v7的值几乎是连续的，并且可以一致地插入到聚集索引的末尾，从而有效避免了索引局部性问题，提高了插入操作的效率。
- 使用 UUID v7 或连续整数（Serial Integer）作为主键的记录，其 ID 值是顺序生成的。这意味着当达到数据页的容量限制时，新记录可以被顺序添加到当前页的末尾，或者在必要时由数据库引擎创建新的数据页。这种顺序访问模式减少了对缓冲池的随机访问，从而降低了因缓冲池满载而频繁写回磁盘的需要。此外，数据库引擎可能会采用延迟写入策略，例如仅在 [WAL](https://zhida.zhihu.com/search?content_id=249818094&content_type=Article&match_order=1&q=WAL&zhida_source=entity)（Write-Ahead Logging）中记录变更，以进一步优化性能。