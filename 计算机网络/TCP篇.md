# 1. TCP 三次握⼿与四次挥⼿⾯试题
![[屏幕截图 2025-02-16 220809.png]]![[屏幕截图 2025-02-16 220857.png]]
### 1.1 TCP 基本认识
#### TCP 头格式
![[Pasted image 20250217155913.png]]
**序列号：⽤来解决⽹络包乱序问题**。
**确认应答号：⽤来解决丢包的问题**。
控制位：
- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的 设定。
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。
#### 什么是TCP
TCP 是**⾯向连接的、可靠的、基于字节流**的传输层通信协议。
#### 什么是TCP连接
建⽴⼀个 TCP 连接是需要客户端与服务端达成三个信息的共识：
- **Socket：由 IP 地址和端⼝号组成**
- **序列号：⽤来解决乱序问题等**
- **窗⼝⼤⼩：⽤来做流量控制**
#### 如何唯⼀确定⼀个 TCP 连接呢？
TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：
- 源地址
- 源端⼝
- ⽬的地址
- ⽬的端⼝
源地址和⽬的地址的字段是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主 机。
源端⼝和⽬的端⼝的字段是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给 哪个进程。
#### UDP 和 TCP 有什么区别呢？分别的应⽤场景是？
TCP 和 UDP 区别：
![[Pasted image 20250217161639.png]]![[Pasted image 20250217161652.png]]
#### TCP 和 UDP 可以使⽤同⼀个端⼝吗？
**可以的**。
传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独⽴的软件模块。
因此，TCP/UDP 各⾃的端⼝号也相互独⽴，如 TCP 有⼀个 80 号端⼝，UDP 也可以有⼀个 80 号端⼝，⼆者并不冲突。![[Pasted image 20250217161412.png]]
### 1.2 TCP连接建立
#### TCP 三次握⼿过程
![[Pasted image 20250217161845.png]]
- ⼀开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态
- 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段 中，同时把 SYN 标志位置为 1，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务 端，表示向服务端发起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT状态。![[Pasted image 20250217171220.png]]
- 服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号 （server_isn），将此序号填⼊ TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。![[Pasted image 20250217171357.png]]
- 客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报 ⽂发送给服务端，这次报⽂可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。![[Pasted image 20250217171420.png]]
- 服务端收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态。
**第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的**。
#### 如何在 Linux 系统中查看 TCP 状态？
TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。
![[Pasted image 20250217171731.png]]
#### 为什么是三次握⼿？不是两次、四次？
- **三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）**
- **三次握⼿才可以同步双⽅的初始序列号**
- **三次握⼿才可以避免资源浪费**
#### 为什么每次建⽴ TCP 连接时，初始化的序列号都要求不⼀样呢？
- 为了防⽌历史报⽂被下⼀个相同四元组的连接接收（主要⽅⾯）；
- 为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收；
#### 既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？
**如果在 TCP 的整个报⽂（头部 + 数据）交给 IP 层进⾏分⽚，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分 ⽚都得重传**。
所以，**为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，进⾏重发时也是以 MSS 为单位，⽽不⽤重 传所有的分⽚**
#### 第⼀次握⼿丢失了，会发⽣什么？
在客户端发送`SYN` 报⽂之后，如果客户端迟迟收不到服务端的 `SYN-ACK `报⽂（第⼆次握⼿），**就会触发「超时重传」机制，重传 SYN 报⽂，⽽且重传的 SYN 报⽂的序列号都是⼀样的**。
在 Linux ⾥，客户端的 SYN 报⽂最⼤重传次数由 tcp_syn_retries 内核参数控制
通常，**每次超时重传的时间是上 ⼀次的 2 倍**。
![[Pasted image 20250217202609.png]]
#### 第⼆次握⼿丢失了，会发⽣什么？
因为第⼆次握⼿报⽂⾥是包含对客户端的第⼀次握⼿的 ACK 确认报⽂，所以，**客户端就会触发超时重传机制，重传 SYN 报⽂**。
如果第⼆次握⼿丢失了，服务端就收不到第三次握⼿，于是**服务端这边会触发超时重 传机制，重传 SYN-ACK 报⽂**。
在 Linux 下，SYN-ACK 报⽂的最⼤重传次数由 tcp_synack_retries 内核参数决定
![[Pasted image 20250217202637.png]]
#### 第三次握⼿丢失了，会发⽣什么？
当第三次握⼿丢失 了，如果服务端那⼀⽅迟迟收不到这个确认报⽂，就会触发超时重传机制，重传 SYN-ACK 报⽂，直到收到第三次握⼿，或者达到最⼤重传次数。
**ACK 报⽂是不会有重传的，当 ACK 丢失了，就由对⽅重传对应的报⽂**。
#### 什么是 SYN 攻击？如何避免 SYN 攻击？
在 TCP 三次握⼿的时候，Linux 内核会维护两个队列，分别是： 半连接队列，也称 SYN 队列； 全连接队列，也称 accept 队列；
![[Pasted image 20250217204955.png]]
SYN 攻击⽅式最直接的表现就会**把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后 续再在收到 SYN 报⽂就会丢弃**，导致客户端⽆法和服务端建⽴连接。
### 1.3 TCP 连接断开
#### TCP 四次挥⼿过程
TCP 断开连接是通过四次挥⼿⽅式。
双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥⼿的过程如下图：
![[Pasted image 20250217211805.png]]
- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。
- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊状态。
- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊`FIN_WAIT_2`状态。
- 等待服务端处理完数据后，也向客户端发送`FIN`报⽂，之后服务端进⼊ LAST_ACK 状 态。
- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态。
- 服务端收到了 ACK 应答报⽂后，就进⼊了 CLOSE 状态，⾄此服务端已经完成连接的关 闭。
- 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSE 状态，⾄此客户端也完成连接的关 闭。
**每个⽅向都需要⼀个 FIN 和⼀个 ACK**。
**主动关闭连接的，才有 TIME_WAIT 状态**。
**在特定情况下，四次挥手可以变成三次挥手：「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第⼆和第三次挥⼿就会合并传输，这样就出现了三次挥手**。
#### 第⼀次挥⼿丢失了，会发⽣什么？
如果第⼀次挥⼿丢失了，那么客户端迟迟收不到被动⽅的 ACK 的话，也就会触发超时重传机 制，重传 FIN 报⽂，重发次数由 tcp_orphan_retries 参数控制。当客户端重传 FIN 报⽂的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报⽂，则会在 等待⼀段时间（时间为上⼀次超时时间的 2 倍），如果还是没能收到第⼆次挥⼿，那么直接 进⼊到 close 状态。![[Pasted image 20250221102052.png]]
#### 第⼆次挥⼿丢失了，会发⽣什么？
ACK 报⽂是不会重传的，所以如果服务端的第⼆次挥⼿丢失了，客户端 就会触发超时重传机制，重传 FIN 报⽂，直到收到服务端的第⼆次挥⼿，或者达到最⼤的重 传次数。
![[Pasted image 20250221102708.png]]
当客户端收到第⼆次挥⼿，对于 close 函数关闭的连接，由于⽆法再发送和接收数据，所以 FIN_WAIT2 状态不可以持续 太久，⽽ tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒。这意味着对于调⽤ close 关闭的连接，如果在 60 秒后还没有收到 FIN 报⽂，客户端（主动关 闭⽅）的连接就会直接关闭。![[Pasted image 20250221103341.png]]
如果主动关闭⽅使⽤ shutdown 函数关闭连接，指定了只关闭发送⽅向，⽽接收 ⽅向并没有关闭，那么意味着主动关闭⽅还是可以接收数据的。，如果主动关闭⽅⼀直没收到第三次挥⼿，那么主动关闭⽅的连接将会⼀直处于 FIN_WAIT2 状态（ tcp_fin_timeout ⽆法控制 shutdown 关闭的连接）![[Pasted image 20250221103455.png]]
#### 第三次挥⼿丢失了，会发⽣什么？
服务端处于 CLOSE_WAIT 状态时，调⽤了 close 函数，内核就会发出 FIN 报⽂，同时连接进 ⼊ LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。如果迟迟收不到这个 ACK，服务端就会重发 FIN 报⽂，重发次数仍然由 tcp_orphan_retrie s 参数控制，这与客户端重发 FIN 报⽂的重传次数控制⽅式是⼀样的。![[Pasted image 20250221103620.png]]
#### 第四次挥⼿丢失了，会发⽣什么？
如果第四次挥⼿的 ACK 报⽂没有到达服务端，服务端就会重发 FIN 报⽂，重发次数仍然由前 ⾯介绍过的 tcp_orphan_retries 参数控制。![[Pasted image 20250221103821.png]]
客户端在收到第三次挥⼿后，就会进⼊ TIME_WAIT 状态，开启时⻓为 2MSL 的定时器， 如果途中再次收到第三次挥⼿（FIN 报⽂）后，就会重置定时器，当等待 2MSL 时⻓ 后，客户端就会断开连接。
#### 为什么 TIME_WAIT 等待的时间是 2MSL？
MSL是**报⽂最⼤⽣存时间**。**2MSL时⻓ 这其实是相当于⾄少允许报⽂丢失⼀次**。
MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 MSL 应该要⼤于 等于 TTL 消耗为 0 的时间，以确保报⽂已被⾃然消亡。 TTL 的值⼀般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报⽂经过 64 个路 由器的时间不会超过 30 秒，如果超过了，就认为报⽂已经消失在⽹络中了。
#### 为什么需要 TIME_WAIT 状态？
*原因⼀：防⽌历史连接中的数据，被后⾯相同四元组的连接错误的接收*
![[Pasted image 20250221110708.png]]
服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。 接着，服务端以相同的四元组重新打开了新连接，前⾯被延迟的 SEQ = 301 这时抵达了 客户端，⽽且该数据报⽂的序列号刚好在客户端接收窗⼝内，因此客户端会正常接收这个 数据报⽂，但是这个数据报⽂是上⼀个连接残留下来的。
为了防⽌历史连接中的数据，被后⾯相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时⻓，**这个时间⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣ 的**。
*原因⼆：保证「被动关闭连接」的⼀⽅，能被正确的关闭*
**TIME-WAIT 作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从 ⽽帮助其正常关闭**。
为了防⽌这种情况出现，客户端必须等待⾜够⻓的时间，确保服务端能够收到 ACK，如果服 务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送⼀个 FIN，这样⼀去⼀ 来刚好两个 MSL 的时间。
![[Pasted image 20250221112130.png]]
#### TIME_WAIT 过多有什么危害？
- 第⼀是占⽤系统资源
- 第⼆是占⽤端⼝资源，端⼝资源也是有限的：如果客户端（主动关闭连接⽅）的 TIME_WAIT 状态过多，占满了所有端⼝资源，那么就⽆ 法对「⽬的 IP+ ⽬的 PORT」都⼀样的服务器发起连接了，但是被使⽤的端⼝，还是可以继 续对另外⼀个服务器发起连接的。
#### 服务器出现⼤量 TIME_WAIT 状态的原因有哪些？
⾸先要知道 TIME_WAIT 状态是主动关闭连接⽅才会出现的状态，所以如果服务器出现⼤量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。
什么场景下服务端会主动断开连接：
- 第⼀个场景：HTTP 没有使⽤⻓连接
- 第⼆个场景：HTTP ⻓连接超时
- 第三个场景：HTTP ⻓连接的请求数量达到上限
*第⼀个场景：HTTP 没有使⽤⻓连接*
**从 HTTP/1.1 开始， 就默认是开启了 Keep-Alive**。
如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header ⾥添加 Connection:close 信息，也就是说，**只要客户端和服务端任意⼀⽅的 HTTP header 中有 Connection:close 信息，那么就⽆法使⽤ HTTP ⻓连接的机制**。
关闭 HTTP ⻓连接机制后，每次请求都要经历这样的过程：建⽴ TCP -> 请求资源 -> 响应资 源 -> 释放连接，那么此⽅式就是 HTTP 短连接。
*第⼆个场景：HTTP ⻓连接超时*
**如果客户端 在完后⼀个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间⼀到，nginx 就 会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接**。
*第三个场景：HTTP ⻓连接的请求数量达到上限*
Web 服务端通常会有个参数，来定义⼀条 HTTP ⻓连接上最⼤能处理的请求数量，**如果达到这个参数设置的最⼤值时，则 nginx 会主动关闭这个⻓连接**，那么此时 服务端上就会出现 TIME_WAIT 状态的连接。
#### 服务器出现⼤量 CLOSE_WAIT 状态的原因有哪些？
**当服务端出现⼤量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调⽤ close 函数关闭连接**。
### 1.4 Socket 编程
#### 针对 TCP 应该如何 Socket 编程？
![[Pasted image 20250224210727.png]]
- 服务端和客户端初始化 socket ，得到⽂件描述符；
- 服务端调⽤ bind ，将 socket 绑定在指定的 IP 地址和端⼝;
- 服务端调⽤ listen ，进⾏监听；
- 服务端调⽤ accept ，等待客户端连接；
- 客户端调⽤ connect ，向服务端的地址和端⼝发起连接请求；
- 服务端 accept 返回⽤于传输的 socket 的⽂件描述符；
- 客户端调⽤ write 写⼊数据；服务端调⽤read 读取数据；
- 客户端断开连接时，会调⽤close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭。
这⾥需要注意的是，服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket， 后续⽤来传输数据。
监听的 socket 和真正⽤来传送数据的 socket，是「两个」 socket，⼀个叫作**监听 socket**，⼀个叫作已完成**连接 socket**。
成功连接建⽴之后，双⽅开始通过 read 和 write 函数来读写数据，就像往⼀个⽂件流⾥⾯写东⻄⼀样。
#### listen 时候参数 backlog 的意义？
Linux内核中会维护两个队列：
- 半连接队列（SYN 队列）：接收到⼀个 SYN 建⽴连接请求，处于 SYN_RCVD 状态；
- 全连接队列（Accpet 队列）：已完成 TCP 三次握⼿过程，处于 ESTABLISHED 状态;
![[Pasted image 20250224213002.png]]
```
int listen (int socketfd, int backlog)
```
**backlog 是 accept 队列，但是上限值是内核参数 somaxconn 的⼤⼩，也就说 accpet 队列⻓度 = min(backlog, somaxconn)**。
#### accept 发⽣在三次握⼿的哪⼀步？
![[Pasted image 20250224213412.png]]
**客户端 connect 成功返回是在第⼆次握⼿，服务端 accept 成功返回是在三次握⼿成功之后**。
#### 客户端调⽤ close 了，连接是断开的流程是什么？
![[Pasted image 20250224213928.png]]
服务端接收到了 FIN 报⽂，TCP 协议栈会为 FIN 包插⼊⼀个⽂件结束符 冲区中，应⽤程序可以通过 read 调⽤来感知这个 FIN 包。**这个 EOF 到接收缓 EOF 会被放在已排队 等候的其他已接收的数据之后**。
#### 没有 accept，能建⽴ TCP 连接吗？
**可以的**。
accpet 系统调⽤并不参与 TCP 三次握⼿过程，它只是负责从 TCP 全连接队列取出⼀个已经 建⽴连接的 socket，⽤户层通过 accpet 系统调⽤拿到了已经建⽴连接的 socket，就可以对 该 socket 进⾏读写操作了。![[Pasted image 20250224215638.png]]
#### 没有 listen，能建⽴ TCP 连接吗？
**可以的**。
客户端是可以⾃⼰连⾃⼰的形成连接（**TCP⾃连接**），也可以两个客户端同时向对⽅发出请 求建⽴连接（**TCP同时打开**），这两个情况都有个共同点，就是**没有服务端参与，也就是没 有 listen，就能 TCP 建⽴连接**。
# 2. TCP 重传、滑动窗⼝、流量控制、拥塞控制
![[Pasted image 20250225144646.png]]
### 2.1 重传机制
TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答。
在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已 收到消息。
![[Pasted image 20250225145232.png]]
TCP 针对数据包丢失的情况，会⽤**重传机制**解决。
#### 超时重传
TCP 会在以下两种情况发⽣超时重传：
- 数据包丢失
- 确认应答丢失
**RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间**。![[Pasted image 20250225145341.png]]
**超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的 值**。
**「超时重传时间 RTO 的值」应该是⼀个动 态变化的值**。
如果超时重发的数据，再次超时的时候，⼜需要重传的时候，TCP 的策略是**超时间隔加倍**。
也就是**每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次 超时，就说明⽹络环境差，不宜频繁反复发送**。
#### 快速重传
快速重传（Fast Retransmit）机制，**不以时间为驱动，⽽是以数据驱动 重传**。
![[Pasted image 20250225145843.png]]
![[Pasted image 20250225150021.png]]
#### SACK ⽅法
**SACK （ Selective Acknowledgment）， 选择性确认**。
这种⽅式需要在 TCP 头部「选项」字段⾥加⼀个 SACK 的东⻄，它**可以将已收到的数据的信 息发送给「发送⽅」**，就**可以只重传丢失的数据**。![[Pasted image 20250225150407.png]]
#### Duplicate SACK
Duplicate SACK ⼜称 D-SACK ，其**主要使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接 收了**。
	例子1：ACK丢包
![[Pasted image 20250225150648.png]]
	例子2：网络延时
	![[Pasted image 20250225151052.png]]
	最后一个ACK，「**接收⽅」回了⼀个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包**。
### 2.2 滑动窗口
![[Pasted image 20250226144030.png]]
**窗⼝⼤⼩就是指⽆需等待确认应答，⽽可以继续发送 数据的最⼤值**。
**累计确认或者累计应答**：![[Pasted image 20250226144250.png]]
TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。**这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这 个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来**。
	发送⽅的滑动窗⼝
![[Pasted image 20250226144550.png]]
**可⽤窗⼝⼤⼩ = SND.WND -（SND.NXT - SND.UNA）**
	接收方的滑动窗口
![[Pasted image 20250226144701.png]]
接收窗⼝的⼤⼩是**约等于**发送窗⼝的⼤⼩的，并不是完全等于，滑动窗口并不是一成不变的。
### 2.3 流量控制
**TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能 ⼒控制发送的数据量，这就是所谓的流量控制**。
![[Pasted image 20250226145602.png]]
![[Pasted image 20250226145611.png]]
#### 操作系统缓冲区与滑动窗⼝的关系
发送窗⼝和 接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中的，⽽操作系统的缓冲区，会 被操作系统调整。 当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。
	例子1
	服务端⾮常的繁忙，当收到客户端的数据时，应⽤层不能及时读取数据。
![[Pasted image 20250226145630.png]]
![[Pasted image 20250226145640.png]]
	例子2：
	当服务端系统资源⾮常紧张的时候，操作系统可能会直接减少了接收缓冲区⼤⼩，这时应⽤ 程序⼜⽆法及时读取缓存数据，会出现数据包丢失的现 象。
![[Pasted image 20250226145833.png]]
服务端收到了 180 字节数据时，**发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包 丢失了**。
**为了防⽌这种情况发⽣，TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗 ⼝，过段时间再减少缓存，这样就可以避免了丢包情况**。
#### 窗口关闭
**如果窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是 窗⼝关闭**。
	窗口关闭潜在的风险
![[Pasted image 20250226150302.png]]
	TCP 是如何解决窗⼝关闭时，潜在的死锁现象呢？
**TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零 窗⼝通知，就启动持续计时器**。
如果持续计时器超时，就会发送**窗⼝探测 ( Window probe ) 报⽂**，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。![[Pasted image 20250226150443.png]]
如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会重新启动持续计时器；
#### 糊涂窗⼝综合症
如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越 ⼩。 **如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反 顾地发送这⼏个字节，这就是糊涂窗⼝综合症**。
	怎么让接收⽅不通告⼩窗⼝呢？
当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩ 值时，就会向发送⽅通告窗⼝为 0，也就阻⽌了发送⽅再发数据过来。 等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ >= MSS，或者接收⽅缓存空间有⼀半可以使⽤， 就可以把窗⼝打开让发送⽅发送数据过来。
	怎么让发送⽅避免发送⼩数据呢？
使⽤ Nagle 算法，该算法的思路是延时处理，只有满⾜下⾯两个条件中的任意⼀个条件，才 可以发送数据： 
- 条件⼀：要等到窗⼝⼤⼩ >= MSS 并且 数据⼤⼩ >= MSS； 
- 条件⼆：收到之前发送数据的 ack 回包；
**接收⽅得满⾜「不通告⼩窗⼝给发送⽅」+ 发送⽅开启 Nagle 算法，才能避免糊涂窗 ⼝综合症**。
### 2.4 拥塞控制
**在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包**。
拥塞控制的⽬的就是**避免「发送⽅」的数据填满整个⽹络**。
**拥塞窗⼝ cwnd是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的**。
发送窗⼝的值是swnd = min(cwnd, rwnd)。
拥塞窗⼝ cwnd 变化的规则：
- 只要⽹络中没有出现拥塞， cwnd 就会增⼤； 
- 但⽹络中出现了拥塞， cwnd 就减少；
其实只要「发送⽅」**发⽣了超时重传，就会 认为⽹络出现了拥塞**。
#### 慢启动
TCP 在刚建⽴连接完成后，⾸先是有个慢启动的过程。
**当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1**。
![[Pasted image 20250226152436.png]]
#### 拥塞避免算法
**每当收到⼀个 ACK 时，cwnd 增加 1/cwnd，变成了线性增⻓**。
![[Pasted image 20250226153511.png]]
#### 拥塞发生
当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：
- 超时重传
- 快速重传
	发⽣超时重传的拥塞发⽣算法
![[Pasted image 20250226154055.png]]
	发⽣快速重传的拥塞发⽣算法
使用快速恢复算法
#### 快速恢复
快速重传和快速恢复算法⼀般同时使⽤![[Pasted image 20250226154820.png]]
# 3. TCP 半连接队列和全连接队列
**当服务端并发处理⼤量请求时，如果 TCP 全连接队列过⼩， 就容易溢出。发⽣ TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端 请求数量上不去的现象。**
当 TCP 全连接队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，进程就在建⽴好的连接上发送请求。只要服务器没有为请求回复 ACK，请 求就会被多次重发。**如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴ 连接**。
**TCP 全连接队列的最⼤值取决于 `somaxconn` 和 `backlog` 之间的最⼩值，也就是 `min(somaxconn, backlog)`。**
**开启 `syncookies` 功能就可以在不使⽤ SYN 半连接队列的情况下成功建⽴连接。**
# 4. 如何优化 TCP?  
![[Pasted image 20250302155434.png]]
**在⾼并发服务器中，为了兼顾⽹速与⼤量的并发连接，我们应当保证缓冲区的动态调整的最 ⼤值达到带宽时延积，⽽最⼩值保持默认的 4K 不变即可。⽽对于内存紧张的服务⽽⾔，调低 默认值是提⾼并发的有效⼿段**。
# 5. 如何理解是 TCP ⾯向字节流协议？
**当⽤户消息通过 UDP 协议传输时，操作系统不会对消息进⾏拆分，也就是每个 UDP 报⽂就是⼀个⽤户消息的边界，操作系统在收到 UDP 报⽂后，会将其插⼊到队列⾥，队列⾥的每⼀个元素就是⼀个 UDP 报⽂**。
**我们不能认为⼀个⽤户消息对应⼀个 TCP 报⽂，正因为这样，所以 TCP 是⾯向字节 流的协议**。
# 6. 为什么 TCP 每次建⽴连接时，初始化序列号都要不⼀ 样呢？
**主要原因是为了防⽌历史报⽂被下⼀个相同四元组的连接接收。**
**序列号和初始化序列号并不是⽆限递增的，会发⽣回绕为初始值的情 况，这意味着⽆法根据序列号来判断新⽼数据。**
**为了解决这个问题，就需要有 TCP 时间戳，⼀个是便于精确计算 RTT ，另⼀个是能防⽌序列号回绕（PAWS）。**
**如果发现收到的 数据包中时间戳不是递增的，则表示该数据包是过期的，就会直接丢弃这个数据包。**
# 7. SYN 报⽂什么时候情况下会被丢弃？
### 7.1 开启 tcp_tw_recycle 参数，并且在 NAT 环境下，造成 SYN 报⽂被丢弃
tcp_tw_reuse，如果开启该选项的话，客户端（连接发起⽅） 在调⽤ connect() 函数时，**如果内核选择到的端⼝，已经被相同四元组的连接占⽤的时候，就会判断该连接 是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并TIME_WAIT 状态 持续的时间超过了 1 秒，那么就会重⽤这个连接，然后就可以正常使⽤该端⼝了**。所以 该选项只适⽤于连接发起⽅。 
tcp_tw_recycle：如果开启该选项的话，允许处于 TIME_WAIT 状态的连接被快速回收。
**tcp_tw_recycle 在使⽤了 NAT 的⽹络下是不安全的！**
对于服务器来说，如果同时开启了recycle 和 timestamps 选项，则会开启⼀种称之为「 per-host 的 PAWS 机制」。
**per-host 是对「对端 IP 做 PAWS 检查」，⽽⾮对「IP + 端⼝」四元组做 PAWS 检查。**
**当客户端 A 通过 NAT ⽹关和服务器建⽴ TCP 连接，然后服务器主动关闭并且快速回收 TIME-WAIT 状态的连接后，客户端 B 也通过 NAT ⽹关和服务器建⽴ TCP 连接，注意客户端 A 和 客户端 B 因为经过相同的 NAT ⽹关，所以是⽤相同的 IP 地址与服务端建⽴ TCP 连 接，如果客户端 B 的 timestamp ⽐ 客户端 A 的 timestamp ⼩，那么由于服务端的 per host 的 PAWS 机制的作⽤，服务端就会丢弃客户端主机 B 发来的 SYN 包。**
### 7.2 accept队列满了
**服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握⼿的 ACK 后，内核会把连接从半 连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。**![[Pasted image 20250303101027.png]]
#### 半连接队列满了
**TCP 半连接队列满了，这时后⾯来的 syn 包都会被丢 弃。但是，如果开启了syncookies 功能，即使半连接队列满了，也不会丢弃syn 包。**
syncookies 是这么做的：服务器根据当前状态计算出⼀个值，放在⼰⽅发出的 SYN+ACK 报 ⽂中发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功，如 下图所示。![[Pasted image 20250303101252.png]]
**要想增⼤半连接队列，我们得知不能只单纯增⼤ tcp_max_syn_backlog 的值，还需⼀同增 ⼤ somaxconn 和 backlog，也就是增⼤全连接队列。**
#### 全连接队列满了
**在服务端并发处理⼤量请求时，如果 TCP accpet 队列过⼩，或者应⽤程序调⽤ accept() 不 及时，就会造成 accpet 队列满了 ，这时后续的连接就会被丢弃，这样就会出现服务端请求 数量上不去的现象。**
调⼤ accpet 队列的最⼤⻓度，调⼤的⽅式是**通过调⼤ backlog 以及 somaxconn 参 数**。
# 8. 已建⽴连接的TCP，收到SYN会发⽣什么？
![[Pasted image 20250303101954.png]]
**处于 Established 状态的服务端，如果收到了客户端的 SYN 报⽂（注意此时的 SYN 报⽂其 实是乱序的，因为 SYN 报⽂的初始化序列号其实是⼀个随机数），会回复⼀个携带了正确序 列号和确认号的 ACK 报⽂，这个 ACK 被称之为 Challenge ACK。 接着，客户端收到这个 Challenge ACK，发现确认号（ack num）并不是⾃⼰期望收到的， 于是就会回 RST 报⽂，服务端收到后，就会释放掉该连接。**
	如何关闭一个TCP连接
![[Pasted image 20250303115718.png]]
**要伪造⼀个能关闭 TCP 连接的 RST 报⽂，必须同时满⾜「四元组相同」和「序列号 是对⽅期望的」这两个条件。**
**服务端响应的这个 ACK 报⽂中的确认号 （ack = x + 100）就是表明服务端下⼀次期望收到的序列号是 x + 100。**
	killcx 的⼯具
![[Pasted image 20250303120440.png]]
	tcpkill 的⼯具
tcpkill ⼯具是在双⽅进⾏ TCP 通信时，拿到对⽅下⼀次期望收到的序列号，然后将序列 号填充到伪造的 RST 报⽂，并将其发送给对⽅，达到关闭 TCP 连接的效果。
**tcpkill ⼯具给服务端和客户端都发送了伪造的 RST 报⽂，从⽽达到关闭⼀条 TCP 连接的效果。tcpkill 只适合关闭活跃的 TCP 连接，不适合⽤来关闭⾮活跃的 TCP 连接。**
# 9. 四次挥⼿中收到乱序的 FIN 包会如何处理？
![[Pasted image 20250303121421.png]]
**因为如果 FIN 报⽂⽐数据包先抵达客 户端，此时 FIN 报⽂其实是⼀个乱序的报⽂，此时客户端的 TCP 连接并不会从 FIN_WAIT_2 状态转换到 TIME_WAIT 状态。**
**在 FIN_WAIT_2 状态时，如果收到乱序的 FIN 报⽂，那么就被会加⼊到「乱序队列」，并不 会进⼊到 TIME_WAIT 状态。 等再次收到前⾯被⽹络延迟的数据包时，会判断乱序队列有没有数据，然后会检测乱序队列 中是否有可⽤的数据，如果能在乱序队列中找到与当前报⽂的序列号保持的顺序的报⽂，就 会看该报⽂是否有 FIN 标志，如果发现有 FIN 标志，这时才会进⼊ TIME_WAIT 状态。**
![[Pasted image 20250303121522.png]]
# 11. 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发 ⽣什么？
![[Pasted image 20250303131314.png]]
**合法 SYN：客户端的 SYN 的「序列号」⽐服务端「期望下⼀个收到的序列号」要⼤， 并且 SYN 的「时间戳」⽐服务端「最后收到的报⽂的时间戳」要⼤。**
**如果处于 TIME_WAIT 状态的连接收到「合法的 SYN 」后，就会重⽤此四元组连接，跳过 2MSL ⽽转变为 SYN_RECV 状态，接着就能进⾏建⽴连接过程。如果处于 TIME_WAIT 状态的连接收到「⾮法的 SYN 」后，就会再回复⼀个第四次挥⼿的 ACK 报⽂，客户端收到后，发现并不是⾃⼰期望收到确认号（ack num），就回 RST 报⽂ 给服务端。**
![[Pasted image 20250303132107.png]]
![[Pasted image 20250303132314.png]]
# 12. TCP 连接，⼀端断电和进程崩溃有什么区别？
TCP keepalive是**TCP 的保活机制，是 TCP 层（内核态） 实现的**，定义一个时间段，在这个时间段中，如果没有任何连接相关的活动，TCP保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果对端程序是正常⼯作的。当 TCP 保活的探测报⽂发送给对端, 对端会正常响应，这 样 TCP 保活时间会被重置，等待下⼀个 TCP 保活时间的到来。如果连续几个探测报文都没有得到相应，则认为当前的TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。
### 12. 1 在没有开启 TCP keepalive，且双⽅⼀直没有数据交互的情况下，如果客户端的「主机崩溃」了，会发⽣什么。
客户端主机崩溃了，**服务端是⽆法感知到的**，在加上服务端没有开启 TCP keepalive，⼜没有 数据交互的情况下，**服务端的 TCP 连接将会⼀直处于 ESTABLISHED 连接状态**，直到服务 端重启进程。
### 12. 2在没有开启 TCP keepalive，且双⽅⼀直没有数据交互的情况下，如果客户端的「进程崩溃」了，会发⽣什么。
即使没有开启 TCP keepalive，且双⽅也没有数据交互的情况下，如果其中⼀⽅的进程 发⽣了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报⽂给对⽅，然后与 对⽅进⾏ TCP 四次挥⼿。
TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第⼀次挥⼿ FIN 报⽂，后续的挥⼿过程也都是在内核完成， 并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP四次挥⼿的 过程。
### 12.3 有数据传输的场景中客户端主机宕机，⼜迅速重启
在客户端主机宕机后，服务端向客户端发送的报⽂会得不到任何的响应，在⼀定时⻓后，服 务端就会触发超时重传机制，重传未得到响应的报⽂。
- 如果客户端主机上没有进程绑定该 TCP 报⽂的⽬标端⼝号，那么客户端内核就会回复 RST 报⽂，重置该 TCP 连接； 
- 如果客户端主机上有进程绑定该 TCP 报⽂的⽬标端⼝号，由于客户端主机重启后，之前 的 TCP 连接的数据结构已经丢失了，客户端内核⾥协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会回复 RST 报⽂，重置该 TCP 连接。
**只要有⼀⽅重启完成后，收到之前 TCP 连接的报⽂，都会回复 RST 报⽂，以断开连 接。**
### 12.4 有数据传输的场景中客户端主机宕机，⼀直没有重启
服务端超时重传报⽂的次数达到⼀定阈值后，内核就会判定出该 TCP 有问题，然 后通过 Socket 接⼝告诉应⽤程序该 TCP 连接出问题了，于是服务端的 TCP 连接就会断开。
# 13. HTTPS 中 TLS 和 TCP 能同时握⼿吗？
**⼀般情况下，不管 TLS 握⼿次数如何，都得先经过 TCP 三次握⼿后才能进⾏，因为 HTTPS 都是基于 TCP 传输协议实现的，得先建⽴完可靠的 TCP 连接才能做 TLS 握⼿的事情。**
需要下⾯这两个条件同时满⾜才可以HTTPS 中 TLS 和 TCP 同时握⼿：
- **客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3；**
- **客户端和服务端已经完成过⼀次通信。**
### 13.1 TCP Fast Open
**开启了 TCP Fast Open 功能，想要绕过 TCP 三次握⼿发送数据，得建⽴第⼆次以后 的通信过程。**
在客户端⾸次建⽴连接时的过程，如下图：![[Pasted image 20250304120351.png]]
对于客户端与服务端的后续通信，客户端可以在第⼀次握⼿的时候携带应⽤数据，从⽽达到 绕过三次握⼿发送数据的效果，整个过程如下图：![[Pasted image 20250304120413.png]]
**如果服务器接受了 SYN 报⽂中的「应⽤数据」，服务器可在握⼿完成之前发送「响应数据」，这就减少了握⼿带来的 1 个 RTT 的时间消耗；**
### 13.2 TLS V1.3
**TLSv1.2 握⼿过程基本都是需要四次，也就是需要经过 2-RTT 才能完成握⼿，然后才能发送 请求，⽽ TLSv1.3 只需要 1-RTT 就能完成 TLS 握⼿**。
TLSv1.3还有**会话恢复**机制，**重连 TLvS1.3 只需要 0-RTT**。
### 13.3 TCP Fast Open + TLS v1.3
**客户端和服务端同时⽀持 TCP Fast Open 功能的情况下，在第⼆次以后到 通信过程中，客户端可以绕过三次握⼿直接发送数据，⽽且服务端也不需要等收到第三次握 ⼿后才发送数据。如果 HTTPS 的 TLS 版本是 1.3，那么 TLS 过程只需要 1-RTT。因此如果「TCP Fast Open + TLSv1.3」情况下，在第⼆次以后的通信过程中，TLS 和 TCP 的握⼿过程是可以同时进⾏的。 如果基于 TCP Fast Open 场景下的 TLSv1.3 0-RTT 会话恢复过程，不仅 TLS 和 TCP 的握 ⼿过程是可以同时进⾏的，⽽且 HTTP 请求也可以在这期间内⼀同完成。**
# 14. TCP Keepalive 和 HTTP Keep-Alive 是⼀个东⻄吗？
**这两个完全是两样不同东西**
- HTTP 的 Keep-Alive，是由**应⽤层（⽤户态）实现的，称为 HTTP ⻓连接**；
- TCP 的 Keepalive，是由 **TCP 层（内核态） 实现的，称为 TCP 保活机制**；
### 14.1 HTTP 的 Keep-Alive
![[Pasted image 20250305083958.png]]
![[Pasted image 20250305084019.png]]
如果每次请求都要经历这样的过程：建⽴ TCP -> 请求资源 -> 响应资源 -> 释放连接，那么此 ⽅式就是 **HTTP 短连接**。
可以使⽤同⼀个 TCP 连接来发送和接 收多个 HTTP 请求/应答，避免了连接建⽴和释放的开销，这个⽅法称为 **HTTP ⻓连接**。
![[Pasted image 20250305084317.png]]
![[Pasted image 20250305084330.png]]
HTTP ⻓连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。
HTTP 的 Keep-Alive 功能在 HTTP 1.0 中默认是关闭的，**从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive**。
为了避免资源浪费的情况，web 服务软件⼀般都会提供 `keepalive_timeout` 参数，⽤来指定 HTTP ⻓连接的超时时间。 ⽐如设置了 HTTP ⻓连接的超时时间是 60 秒，web 服务软件就会**启动⼀个定时器**，如果客 户端在完后⼀个 HTTP 请求后，在 60 秒内都没有再发起新的请求，**定时器的时间⼀到，就会触发回调函数来释放该连接**。
### 14.2 TCP 的 Keepalive
![[Pasted image 20250305085152.png]]
# 15. TCP 协议有什么缺陷？
- 升级 TCP 的⼯作很困难；
- TCP 建⽴连接的延迟；
- TCP 存在队头阻塞问题；
- ⽹络迁移需要重新建⽴ TCP 连接；
# 16. 如何基于 UDP 协议实现可靠传输？
![[Pasted image 20250305091317.png]]
### 16.1 QUIC 是如何实现可靠传输的？
![[Pasted image 20250305095108.png]]
#### Packet Header
![[Pasted image 20250305095127.png]]
Packet Header 细分这两种：
- Long Packet Header ⽤于⾸次建⽴连接。
- Short Packet Header ⽤于⽇常传输数据。
`Short Packet Header` 中的 `Packet Number` 是每个报⽂独⼀⽆⼆的编号，它是**严格递增的**。可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；![[Pasted image 20250305095249.png]]
**QUIC 使⽤的 Packet Number 单调递增的设计，可以让数据包不再像 TCP 那样必须有序确认，QUIC ⽀持乱序确认，当数据包Packet N 丢失后，只要有新的已接 收数据包确认，当前窗⼝就会继续向右滑动**。
#### QUIC Frame Header
⼀个 Packet 报⽂中可以存放多个 QUIC Frame。
![[Pasted image 20250305095432.png]]
Stream 类型的 Frame 格式：![[Pasted image 20250305095541.png]]
**通过 Stream ID + Offset 字段信息实现数据的有序性。丢 失的数据包和重传的数据包 Stream ID 与 Offset 都⼀致，说明这两个数据包的内容⼀致**。
**QUIC 通过单向递增的 Packet Number，配合 Stream ID 与 Offset 字段信息， 可以⽀持乱序确认⽽不影响数据包的正确组装**
### 16.2 QUIC 是如何解决 TCP 队头阻塞问题的？
#### 什么是 TCP 队头阻塞问题？
**TCP 队头阻塞的问题要从两个⻆度看，⼀个是发送窗⼝的队头阻塞，另外⼀个是接收窗⼝的 队头阻塞。**
 1. 发送窗⼝的队头阻塞。
**但是如果某个数据报⽂丢失或者其对应的 ACK 报⽂在⽹络中丢失，会导致发送⽅⽆法移动发 送窗⼝，这时就⽆法再发送新的数据。**
**此时的第 5 字节相当于“队头”，因为没有收到“队头”的 ACK 确认报⽂，导致发送窗⼝⽆法往 前移动，此时发送⽅就⽆法继续发送后⾯的数据，相当于按下了发送⾏为的暂停键，这就是 发送窗⼝的队头阻塞问题。**
2. 接收窗⼝的队头阻塞
**当接收窗⼝收到的数据不是有序的，⽐如收到第 33～40 字节的数据，由于第 32 字节 数据没有收到， 接收窗⼝⽆法向前滑动，那么即使先收到第 33～40 字节的数据，这些数据 也⽆法被应⽤层读取的。**
#### HTTP/2 的队头阻塞
**但是 HTTP/2 多个 Stream 请求都是在⼀条 TCP 连接上传输，这意味着多个 Stream 共⽤同 ⼀个 TCP 滑动窗⼝，那么当发⽣数据丢失，滑动窗⼝是⽆法往前移动的，此时就会阻塞住所 有的 HTTP 请求，这属于 TCP 层队头阻塞。**![[Pasted image 20250305094702.png]]
#### 没有队头阻塞的 QUIC
**QUIC 给每⼀个 Stream 都分配了⼀个独⽴的滑动窗⼝，这样使得⼀个连接上的多个 Stream 之间没有依赖关系，都是相互独⽴的，各⾃控制的滑动窗⼝。**![[Pasted image 20250305094656.png]]
### 16.3 QUIC 是如何做流量控制的？
**QUIC 的 每个 Stream 都有各⾃的滑动窗⼝，不同 Stream 互相独⽴，队头的 Stream A 被 阻塞后，不妨碍 StreamB、C的读取。**
QUIC 实现了两种级别的流量控制，分别为 Stream 和 Connection 两种级别：
- **Stream 级别的流量控制**：Stream 可以认为就是⼀条 HTTP 请求，每个 Stream 都有独 ⽴的滑动窗⼝，所以每个 Stream 都可以做流量控制，防⽌单个 Stream 消耗连接 （Connection）的全部接收缓冲。
- **Connection 流量控制**：限制连接中所有 Stream 相加起来的总字节数，防⽌发送⽅超过 连接的缓冲容量。
#### Stream 级别的流量控制
**接收窗⼝的左边界取决于接收到的最⼤偏移字节数**
#### Connection 流量控制
对于 Connection 级别的流量窗⼝，其接收窗⼝⼤⼩就是各个 Stream 接收窗⼝⼤⼩之和。
### 16.4 QUIC 对拥塞控制改进
**QUIC 可以随浏览器更新，QUIC 的拥塞控制算法就可以有较 快的迭代速度。可以针对不同的应⽤设置不同的拥塞控制算法。**
### 16.5 QUIC 更快的连接建⽴
**HTTP/3 的 QUIC 协议并不是与 TLS 分层，⽽是QUIC 内部包含了 TLS，它在⾃⼰的帧 会携带 TLS ⾥的“记录”，再加上 QUIC 使⽤的是 TLS1.3，因此仅需 1 个 RTT 就可以「同 时」完成建⽴连接与密钥协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信 息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果。**
### 16.6 QUIC 是如何迁移连接的？
QUIC 协议通过**连接 ID**来标记通信的两个端点，达到了**连接迁移**的功能。
# 17. 服务端没有 listen，客户端发起连接建⽴，会发⽣什 么？
**服务端如果只 bind 了 IP 地址和端⼝，⽽没有调⽤ listen 的 话，然后客户端对服务端发起了连接建⽴，服务端会回 RST 报⽂。**
### 17.1 没有 listen，能建⽴ TCP 连接吗？
**客户端是可以⾃⼰连⾃⼰的形成连接（TCP⾃连接），也可以两个客户端 同时向对⽅发出请求建⽴连接（TCP同时打开），这两个情况都有个共同点，就是没有服务 端参与，也就是没有listen，就能建⽴连接。**
# 18. 没有 accept，能建⽴ TCP 连接吗？
**就算不执⾏accept()⽅法，三次握⼿照常进⾏，并顺利建⽴连接。在服务端执⾏accept()前，如果客户端发送消息给服务端，服务端是能够正常回 复ack确认包的。**
![[Pasted image 20250305102250.png]]
内核会为每⼀个处于 `LISTEN` 状态的 半连接队列和全连接队列。**虽然都叫队列，但其实全连接队列（icsk_accept_queue）是个链表，⽽半连接队列 （syn_table）是个哈希表。**
![[Pasted image 20250305102404.png]]
**建⽴连接的过程中根本不需要 accept() 参与， 执⾏accept()只是为了从全连接队列⾥取出⼀条连接。**
# 19. ⽤了 TCP 协议，数据⼀定不会丢吗？
### 19.1 数据包的发送流程
![[Pasted image 20250307094701.png]]
### 19.2 建立连接时丢包
半连接队列和全连接队列满了，新来的包就会被丢弃。
### 19.3 流量控制丢包
应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消。让数据按一定的规则排个队依次处理，也就是所谓的**qdisc**（排队规则），也是我们常说的**流量控制**机制。排队，得先有个队列，而队列有个**长度**。当发送数据过快，流控队列长度`txqueuelen`又不够大时，就容易出现**丢包**现象。
![[Pasted image 20250307095542.png]]
### 19.4 网卡丢包
#### RingBuffer 过小导致丢包
在接收数据时，会将数据暂存到`RingBuffer`接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个**缓冲区过小**，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生**丢包**。
![[Pasted image 20250307095800.png]]

一个网卡里是可以有**多个 RingBuffer**的。
#### 网卡性能不足
网卡作为硬件，**传输速度是有上限的**。单位是**Mb**，这里的**b 是指 bit，而不是 Byte。1Byte=8bit**。所以 10000Mb/s 还要除以 8，也就是理论上网卡最大传输速度是`1000/8 = 125MB/s`。
**txkB/s 是指当前每秒发送的字节（byte）总数，rxkB/s 是指每秒接收的字节（byte）总数**。
### 19.5 接收缓冲区丢包
我们一般使用`TCP socket`进行网络编程的时候，内核都会分配一个**发送缓冲区**和一个**接收缓冲区**。
当我们想要发一个数据包，会在代码里执行`send(msg)`，将数据拷贝到内核**发送缓冲区**就完事**返回**了，至于**什么时候发数据，发多少数据**，这个后续由内核自己做决定。![[Pasted image 20250307100258.png]]
不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的**最小值，默认值和最大值（min、default、max）。缓冲区会在 min 和 max 之间动态调整。**
**如果缓冲区设置过小会怎么样？**
对于**发送缓冲区**，执行 send 的时候，如果是**阻塞**调用，那就会等，等到缓冲区有空位可以发数据。![[20250307-0206-32.0757449.mp4]]
如果是**非阻塞**调用，就会**立刻返回**一个 `EAGAIN` 错误信息。让应用程序下次再重试。这种情况下一般不会发生丢包。![[20250307-0208-55.2459727.mp4]]
当接受缓冲区满了，TCP 接收窗口会变为 0，也就是所谓的**零窗口**，并且会通过数据包里的`win=0`，告诉发送端，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生**丢包**。![[Pasted image 20250307101017.png]]
### 19.6 两端之间的网络丢包
### 19.7 发生丢包了怎么办
**丢包是很常见的，几乎不可避免的一件事情**。
### 19.8  用了 TCP 协议就一定不会丢包吗
也会丢包。
TCP 保证的可靠性，是**传输层的可靠性**。也就是说，**TCP 只保证数据从 A 机器的传输层可靠地发到 B 机器的传输层。**
![[Pasted image 20250307101344.png]]
**TCP 只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。**
# 20 TCP 四次挥手，可以变成三次吗？

### 20.1 TCP 四次挥手
TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被**放在已排队等候的其他已接收的数据之后**，所以必须要得继续 read 接收缓冲区已接收的数据；当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 **read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数**。
#### 为什么 TCP 挥手需要四次呢？
服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，**但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序**：**是否要发送第三次挥手的控制权不在内核，而是在被动关闭方（上图的服务端）的应用程序，因为应用程序可能还有数据要发送，由应用程序决定什么时候调用关闭连接的函数，当调用了关闭连接的函数，内核就会发送 FIN 报文了，** 所以服务端的 ACK 和 FIN 一般都会分开发送。
> FIN 报文一定得调用关闭连接的函数，才会发送吗？

不一定。如果进程退出了，不管是不是正常退出，还是异常退出（如进程崩溃），内核都会发送 FIN 报文，与对方完成四次挥手。
#### 粗暴关闭 vs 优雅关闭
关闭的连接的函数有两种函数：
- close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。
- shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。
如果客户端是用 close 函数来关闭连接，那么在 TCP 	四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。![[Pasted image 20250307112049.png]]
相对的，shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。![[Pasted image 20250307112147.png]]
### 20.2 什么情况会出现三次挥手？
当被动关闭方在 TCP 挥手过程中，「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手**。TCP 延迟确认机制是默认开启的
![[Pasted image 20250307112330.png]]
> 什么是  TCP 延迟确认机制？

TCP 延迟确认的策略：
- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK
![[Pasted image 20250307112533.png]]
# 21. TCP 序列号和确认号是如何变化的？
### 21.1 万能公式
**发送的 TCP 报⽂**：
- **公式⼀：序列号 = 上⼀次发送的序列号 + len（数据⻓度）。特殊情况，如果上⼀次发送 的报⽂是 SYN 报⽂或者 FIN 报⽂，则改为 上⼀次发送的序列号 + 1。
- **公式⼆：确认号 = 上⼀次收到的报⽂中的序列号 + len（数据⻓度）。特殊情况，如果收 到的是 SYN 报⽂或者 FIN 报⽂，则改为上⼀次收到的报⽂中的序列号 + 1。
![[Pasted image 20250307113832.png]]
三个重点字段的作用**：
- 序列号：在建⽴连接时由内核⽣成的随机数作为其初始值，通过 SYN 报⽂传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。**⽤来解决⽹络包乱序问 题**。
- 确认号：指下⼀次「期望」收到的数据的序列号，发送端收到接收⽅发来的 ACK 确认报 ⽂以后，就可以认为在这个序号以前的数据都已经被正常接收。**⽤来解决丢包的问题**。
- 控制位：⽤来标识 TCP 报⽂是什么类型的报⽂，⽐如是 SYN 报⽂、数据报⽂、ACK 报 ⽂，FIN 报⽂等。
### 21.2 三次握⼿阶段的变化
![[Pasted image 20250307114505.png]]
SYN 报⽂是特殊的 TCP 报⽂，⽤于建⽴连接时使⽤，虽然 SYN 报⽂不携带⽤户数据，**但是 TCP 将 SYN 报⽂视为 1 字节的数据**。
当对⽅收到了 SYN 报⽂后，在回复 ACK 报⽂时，就 需要将 ACK 报⽂中的确认号设置为 SYN 的序列号 + 1 ，这样做是有两个⽬的： 
- **告诉对⽅，我⽅已经收到 SYN 报⽂**。 
- **告诉对⽅，我⽅下⼀次「期望」收到的报⽂的序列号为此确认号，⽐如客户端与服务端完 成三次握⼿之后，服务端接下来期望收到的是序列号为 client_isn + 1 的 TCP 数据报⽂。**
### 21.3 数据传输阶段的变化
![[Pasted image 20250307114722.png]]
**客户端与服务端完成 TCP 三次握⼿后，发送的第⼀个 「TCP 数据报⽂的序列号 和确认号」都是和「第三次握⼿的 ACK 报⽂中序列号和确认号」⼀样的。**
### 21.4 四次挥⼿阶段的变化 
![[Pasted image 20250307115259.png]]
