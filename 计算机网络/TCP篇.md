# 1. TCP 三次握⼿与四次挥⼿⾯试题
![[屏幕截图 2025-02-16 220809.png]]![[屏幕截图 2025-02-16 220857.png]]
### 1.1 TCP 基本认识
#### TCP 头格式
![[Pasted image 20250217155913.png]]
**序列号：⽤来解决⽹络包乱序问题**。
**确认应答号：⽤来解决丢包的问题**。
控制位：
- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的 设定。
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。
#### 什么是TCP
TCP 是**⾯向连接的、可靠的、基于字节流**的传输层通信协议。
#### 什么是TCP连接
建⽴⼀个 TCP 连接是需要客户端与服务端达成三个信息的共识：
- **Socket：由 IP 地址和端⼝号组成**
- **序列号：⽤来解决乱序问题等**
- **窗⼝⼤⼩：⽤来做流量控制**
#### 如何唯⼀确定⼀个 TCP 连接呢？
TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：
- 源地址
- 源端⼝
- ⽬的地址
- ⽬的端⼝
源地址和⽬的地址的字段是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主 机。
源端⼝和⽬的端⼝的字段是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给 哪个进程。
#### UDP 和 TCP 有什么区别呢？分别的应⽤场景是？
TCP 和 UDP 区别：
![[Pasted image 20250217161639.png]]![[Pasted image 20250217161652.png]]
#### TCP 和 UDP 可以使⽤同⼀个端⼝吗？
**可以的**。
传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独⽴的软件模块。
因此，TCP/UDP 各⾃的端⼝号也相互独⽴，如 TCP 有⼀个 80 号端⼝，UDP 也可以有⼀个 80 号端⼝，⼆者并不冲突。![[Pasted image 20250217161412.png]]
### 1.2 TCP连接建立
#### TCP 三次握⼿过程
![[Pasted image 20250217161845.png]]
- ⼀开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态
- 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段 中，同时把 SYN 标志位置为 1，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务 端，表示向服务端发起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT状态。![[Pasted image 20250217171220.png]]
- 服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号 （server_isn），将此序号填⼊ TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确 认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1。最后把该 报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。![[Pasted image 20250217171357.png]]
- 客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报 ⽂发送给服务端，这次报⽂可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。![[Pasted image 20250217171420.png]]
- 服务端收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态。
**第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的**。
#### 如何在 Linux 系统中查看 TCP 状态？
TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。
![[Pasted image 20250217171731.png]]
#### 为什么是三次握⼿？不是两次、四次？
- **三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）**
- **三次握⼿才可以同步双⽅的初始序列号**
- **三次握⼿才可以避免资源浪费**
#### 为什么每次建⽴ TCP 连接时，初始化的序列号都要求不⼀样呢？
- 为了防⽌历史报⽂被下⼀个相同四元组的连接接收（主要⽅⾯）；
- 为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收；
#### 既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？
**如果在 TCP 的整个报⽂（头部 + 数据）交给 IP 层进⾏分⽚，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分 ⽚都得重传**。
所以，**为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，进⾏重发时也是以 MSS 为单位，⽽不⽤重 传所有的分⽚**
#### 第⼀次握⼿丢失了，会发⽣什么？
在客户端发送`SYN` 报⽂之后，如果客户端迟迟收不到服务端的 `SYN-ACK `报⽂（第⼆次握⼿），**就会触发「超时重传」机制，重传 SYN 报⽂，⽽且重传的 SYN 报⽂的序列号都是⼀样的**。
在 Linux ⾥，客户端的 SYN 报⽂最⼤重传次数由 tcp_syn_retries 内核参数控制
通常，**每次超时重传的时间是上 ⼀次的 2 倍**。
![[Pasted image 20250217202609.png]]
#### 第⼆次握⼿丢失了，会发⽣什么？
因为第⼆次握⼿报⽂⾥是包含对客户端的第⼀次握⼿的 ACK 确认报⽂，所以，**客户端就会触发超时重传机制，重传 SYN 报⽂**。
如果第⼆次握⼿丢失了，服务端就收不到第三次握⼿，于是**服务端这边会触发超时重 传机制，重传 SYN-ACK 报⽂**。
在 Linux 下，SYN-ACK 报⽂的最⼤重传次数由 tcp_synack_retries 内核参数决定
![[Pasted image 20250217202637.png]]
#### 第三次握⼿丢失了，会发⽣什么？
当第三次握⼿丢失 了，如果服务端那⼀⽅迟迟收不到这个确认报⽂，就会触发超时重传机制，重传 SYN-ACK 报⽂，直到收到第三次握⼿，或者达到最⼤重传次数。
**ACK 报⽂是不会有重传的，当 ACK 丢失了，就由对⽅重传对应的报⽂**。
#### 什么是 SYN 攻击？如何避免 SYN 攻击？
在 TCP 三次握⼿的时候，Linux 内核会维护两个队列，分别是： 半连接队列，也称 SYN 队列； 全连接队列，也称 accept 队列；
![[Pasted image 20250217204955.png]]
SYN 攻击⽅式最直接的表现就会**把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后 续再在收到 SYN 报⽂就会丢弃**，导致客户端⽆法和服务端建⽴连接。
### 1.3 TCP 连接断开
#### TCP 四次挥⼿过程
TCP 断开连接是通过四次挥⼿⽅式。
双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥⼿的过程如下图：
![[Pasted image 20250217211805.png]]
- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。
- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊状态。
- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊`FIN_WAIT_2`状态。
- 等待服务端处理完数据后，也向客户端发送`FIN`报⽂，之后服务端进⼊ LAST_ACK 状 态。
- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态。
- 服务端收到了 ACK 应答报⽂后，就进⼊了 CLOSE 状态，⾄此服务端已经完成连接的关 闭。
- 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSE 状态，⾄此客户端也完成连接的关 闭。
**每个⽅向都需要⼀个 FIN 和⼀个 ACK**。
**主动关闭连接的，才有 TIME_WAIT 状态**。
**在特定情况下，四次挥手可以变成三次挥手的**。
#### 第⼀次挥⼿丢失了，会发⽣什么？
如果第⼀次挥⼿丢失了，那么客户端迟迟收不到被动⽅的 ACK 的话，也就会触发超时重传机 制，重传 FIN 报⽂，重发次数由 tcp_orphan_retries 参数控制。当客户端重传 FIN 报⽂的次数超过 tcp_orphan_retries 后，就不再发送 FIN 报⽂，则会在 等待⼀段时间（时间为上⼀次超时时间的 2 倍），如果还是没能收到第⼆次挥⼿，那么直接 进⼊到 close 状态。![[Pasted image 20250221102052.png]]
#### 第⼆次挥⼿丢失了，会发⽣什么？
ACK 报⽂是不会重传的，所以如果服务端的第⼆次挥⼿丢失了，客户端 就会触发超时重传机制，重传 FIN 报⽂，直到收到服务端的第⼆次挥⼿，或者达到最⼤的重 传次数。
![[Pasted image 20250221102708.png]]
当客户端收到第⼆次挥⼿，对于 close 函数关闭的连接，由于⽆法再发送和接收数据，所以 FIN_WAIT2 状态不可以持续 太久，⽽ tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒。这意味着对于调⽤ close 关闭的连接，如果在 60 秒后还没有收到 FIN 报⽂，客户端（主动关 闭⽅）的连接就会直接关闭。![[Pasted image 20250221103341.png]]
如果主动关闭⽅使⽤ shutdown 函数关闭连接，指定了只关闭发送⽅向，⽽接收 ⽅向并没有关闭，那么意味着主动关闭⽅还是可以接收数据的。，如果主动关闭⽅⼀直没收到第三次挥⼿，那么主动关闭⽅的连接将会⼀直处于 FIN_WAIT2 状态（ tcp_fin_timeout ⽆法控制 shutdown 关闭的连接）![[Pasted image 20250221103455.png]]
#### 第三次挥⼿丢失了，会发⽣什么？
服务端处于 CLOSE_WAIT 状态时，调⽤了 close 函数，内核就会发出 FIN 报⽂，同时连接进 ⼊ LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。如果迟迟收不到这个 ACK，服务端就会重发 FIN 报⽂，重发次数仍然由 tcp_orphan_retrie s 参数控制，这与客户端重发 FIN 报⽂的重传次数控制⽅式是⼀样的。![[Pasted image 20250221103620.png]]
#### 第四次挥⼿丢失了，会发⽣什么？
如果第四次挥⼿的 ACK 报⽂没有到达服务端，服务端就会重发 FIN 报⽂，重发次数仍然由前 ⾯介绍过的 tcp_orphan_retries 参数控制。![[Pasted image 20250221103821.png]]
客户端在收到第三次挥⼿后，就会进⼊ TIME_WAIT 状态，开启时⻓为 2MSL 的定时器， 如果途中再次收到第三次挥⼿（FIN 报⽂）后，就会重置定时器，当等待 2MSL 时⻓ 后，客户端就会断开连接。
#### 为什么 TIME_WAIT 等待的时间是 2MSL？
MSL是**报⽂最⼤⽣存时间**。**2MSL时⻓ 这其实是相当于⾄少允许报⽂丢失⼀次**。
MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 MSL 应该要⼤于 等于 TTL 消耗为 0 的时间，以确保报⽂已被⾃然消亡。 TTL 的值⼀般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报⽂经过 64 个路 由器的时间不会超过 30 秒，如果超过了，就认为报⽂已经消失在⽹络中了。
#### 为什么需要 TIME_WAIT 状态？
*原因⼀：防⽌历史连接中的数据，被后⾯相同四元组的连接错误的接收*
![[Pasted image 20250221110708.png]]
服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。 接着，服务端以相同的四元组重新打开了新连接，前⾯被延迟的 SEQ = 301 这时抵达了 客户端，⽽且该数据报⽂的序列号刚好在客户端接收窗⼝内，因此客户端会正常接收这个 数据报⽂，但是这个数据报⽂是上⼀个连接残留下来的。
为了防⽌历史连接中的数据，被后⾯相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 2MSL 时⻓，**这个时间⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣ 的**。
*原因⼆：保证「被动关闭连接」的⼀⽅，能被正确的关闭*
**TIME-WAIT 作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从 ⽽帮助其正常关闭**。
为了防⽌这种情况出现，客户端必须等待⾜够⻓的时间，确保服务端能够收到 ACK，如果服 务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送⼀个 FIN，这样⼀去⼀ 来刚好两个 MSL 的时间。
![[Pasted image 20250221112130.png]]
#### TIME_WAIT 过多有什么危害？
- 第⼀是占⽤系统资源
- 第⼆是占⽤端⼝资源，端⼝资源也是有限的
#### 服务器出现⼤量 TIME_WAIT 状态的原因有哪些？
⾸先要知道 TIME_WAIT 状态是主动关闭连接⽅才会出现的状态，所以如果服务器出现⼤量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。
什么场景下服务端会主动断开连接：
- 第⼀个场景：HTTP 没有使⽤⻓连接
- 第⼆个场景：HTTP ⻓连接超时
- 第三个场景：HTTP ⻓连接的请求数量达到上限
*第⼀个场景：HTTP 没有使⽤⻓连接*
**从 HTTP/1.1 开始， 就默认是开启了 Keep-Alive**。
如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header ⾥添加 Connection:close 信息，也就是说，**只要客户端和服务端任意⼀⽅的 HTTP header 中有 Connection:close 信息，那么就⽆法使⽤ HTTP ⻓连接的机制**。
关闭 HTTP ⻓连接机制后，每次请求都要经历这样的过程：建⽴ TCP -> 请求资源 -> 响应资 源 -> 释放连接，那么此⽅式就是 HTTP 短连接。
*第⼆个场景：HTTP ⻓连接超时*
**如果客户端 在完后⼀个 HTTP 请求后，在 60 秒内都没有再发起新的请求，定时器的时间⼀到，nginx 就 会触发回调函数来关闭该连接，那么此时服务端上就会出现 TIME_WAIT 状态的连接**。
*第三个场景：HTTP ⻓连接的请求数量达到上限*
Web 服务端通常会有个参数，来定义⼀条 HTTP ⻓连接上最⼤能处理的请求数量，**如果达到这个参数设置的最⼤值时，则 nginx 会主动关闭这个⻓连接**，那么此时 服务端上就会出现 TIME_WAIT 状态的连接。
#### 服务器出现⼤量 CLOSE_WAIT 状态的原因有哪些？
**当服务端出现⼤量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调⽤ close 函数关闭连接**。
### 1.4 Socket 编程
#### 针对 TCP 应该如何 Socket 编程？
![[Pasted image 20250224210727.png]]
- 服务端和客户端初始化 socket ，得到⽂件描述符；
- 服务端调⽤ bind ，将 socket 绑定在指定的 IP 地址和端⼝;
- 服务端调⽤ listen ，进⾏监听；
- 服务端调⽤ accept ，等待客户端连接；
- 客户端调⽤ connect ，向服务端的地址和端⼝发起连接请求；
- 服务端 accept 返回⽤于传输的 socket 的⽂件描述符；
- 客户端调⽤ write 写⼊数据；服务端调⽤read 读取数据；
- 客户端断开连接时，会调⽤close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待处理完数据后，服务端调⽤ close ，表示连接关闭。
这⾥需要注意的是，服务端调⽤ accept 时，连接成功了会返回⼀个已完成连接的 socket， 后续⽤来传输数据。
监听的 socket 和真正⽤来传送数据的 socket，是「两个」 socket，⼀个叫作**监听 socket**，⼀个叫作已完成**连接 socket**。
成功连接建⽴之后，双⽅开始通过 read 和 write 函数来读写数据，就像往⼀个⽂件流⾥⾯写东⻄⼀样。
#### listen 时候参数 backlog 的意义？
Linux内核中会维护两个队列：
- 半连接队列（SYN 队列）：接收到⼀个 SYN 建⽴连接请求，处于 SYN_RCVD 状态；
- 全连接队列（Accpet 队列）：已完成 TCP 三次握⼿过程，处于 ESTABLISHED 状态;
![[Pasted image 20250224213002.png]]
```
int listen (int socketfd, int backlog)
```
**backlog 是 accept 队列，但是上限值是内核参数 somaxconn 的⼤⼩，也就说 accpet 队列⻓度 = min(backlog, somaxconn)**。
#### accept 发⽣在三次握⼿的哪⼀步？
![[Pasted image 20250224213412.png]]
**客户端 connect 成功返回是在第⼆次握⼿，服务端 accept 成功返回是在三次握⼿成功之后**。
#### 客户端调⽤ close 了，连接是断开的流程是什么？
![[Pasted image 20250224213928.png]]
服务端接收到了 FIN 报⽂，TCP 协议栈会为 FIN 包插⼊⼀个⽂件结束符 冲区中，应⽤程序可以通过 read 调⽤来感知这个 FIN 包。**这个 EOF 到接收缓 EOF 会被放在已排队 等候的其他已接收的数据之后**。
#### 没有 accept，能建⽴ TCP 连接吗？
**可以的**。
accpet 系统调⽤并不参与 TCP 三次握⼿过程，它只是负责从 TCP 全连接队列取出⼀个已经 建⽴连接的 socket，⽤户层通过 accpet 系统调⽤拿到了已经建⽴连接的 socket，就可以对 该 socket 进⾏读写操作了。![[Pasted image 20250224215638.png]]
#### 没有 listen，能建⽴ TCP 连接吗？
**可以的**。
客户端是可以⾃⼰连⾃⼰的形成连接（**TCP⾃连接**），也可以两个客户端同时向对⽅发出请 求建⽴连接（**TCP同时打开**），这两个情况都有个共同点，就是**没有服务端参与，也就是没 有 listen，就能 TCP 建⽴连接**。
# 2. TCP 重传、滑动窗⼝、流量控制、拥塞控制
![[Pasted image 20250225144646.png]]
### 2.1 重传机制
TCP 实现可靠传输的⽅式之⼀，是通过序列号与确认应答。
在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已 收到消息。
![[Pasted image 20250225145232.png]]
TCP 针对数据包丢失的情况，会⽤**重传机制**解决。
#### 超时重传
TCP 会在以下两种情况发⽣超时重传：
- 数据包丢失
- 确认应答丢失
**RTT 指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间**。![[Pasted image 20250225145341.png]]
**超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的 值**。
**「超时重传时间 RTO 的值」应该是⼀个动 态变化的值**。
如果超时重发的数据，再次超时的时候，⼜需要重传的时候，TCP 的策略是**超时间隔加倍**。
也就是**每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次 超时，就说明⽹络环境差，不宜频繁反复发送**。
#### 快速重传
快速重传（Fast Retransmit）机制，**不以时间为驱动，⽽是以数据驱动 重传**。
![[Pasted image 20250225145843.png]]
![[Pasted image 20250225150021.png]]
#### SACK ⽅法
**SACK （ Selective Acknowledgment）， 选择性确认**。
这种⽅式需要在 TCP 头部「选项」字段⾥加⼀个 SACK 的东⻄，它**可以将已收到的数据的信 息发送给「发送⽅」**，就**可以只重传丢失的数据**。![[Pasted image 20250225150407.png]]
#### Duplicate SACK
Duplicate SACK ⼜称 D-SACK ，其**主要使⽤了 SACK 来告诉「发送⽅」有哪些数据被重复接 收了**。
	例子1：ACK丢包
![[Pasted image 20250225150648.png]]
	例子2：网络延时
	![[Pasted image 20250225151052.png]]
	最后一个ACK，「**接收⽅」回了⼀个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包**。
### 2.2 滑动窗口
