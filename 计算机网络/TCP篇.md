# 1. TCP 三次握⼿与四次挥⼿⾯试题
![[屏幕截图 2025-02-16 220809.png]]![[屏幕截图 2025-02-16 220857.png]]
### 1.1 TCP 基本认识
#### TCP 头格式
![[Pasted image 20250217155913.png]]
**序列号：⽤来解决⽹络包乱序问题**。
**确认应答号：⽤来解决丢包的问题**。
控制位：
- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1 。
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的 设定。
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。
#### 什么是TCP
TCP 是**⾯向连接的、可靠的、基于字节流**的传输层通信协议。
#### 什么是TCP连接
建⽴⼀个 TCP 连接是需要客户端与服务端达成三个信息的共识：
- **Socket：由 IP 地址和端⼝号组成**
- **序列号：⽤来解决乱序问题等**
- **窗⼝⼤⼩：⽤来做流量控制**
#### 如何唯⼀确定⼀个 TCP 连接呢？
TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：
- 源地址
- 源端⼝
- ⽬的地址
- ⽬的端⼝
源地址和⽬的地址的字段是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主 机。
源端⼝和⽬的端⼝的字段是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给 哪个进程。
#### UDP 和 TCP 有什么区别呢？分别的应⽤场景是？
TCP 和 UDP 区别：
![[Pasted image 20250217161639.png]]![[Pasted image 20250217161652.png]]
#### TCP 和 UDP 可以使⽤同⼀个端⼝吗？
**可以的**。
传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独⽴的软件模块。
因此，TCP/UDP 各⾃的端⼝号也相互独⽴，如 TCP 有⼀个 80 号端⼝，UDP 也可以有⼀个 80 号端⼝，⼆者并不冲突。![[Pasted image 20250217161412.png]]
# 1.2 TCP连接建立
#### TCP 三次握⼿过程
![[Pasted image 20250217161845.png]]
- ⼀开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态
- 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段 中，同时把 SYN 标志位置为 1，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务 端，表示向服务端发起连接，该报⽂不包含应⽤层数据，之后客户端处于 SYN-SENT状态。![[Pasted image 20250217171220.png]]
- 服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号 （server_isn），将此序号填⼊ TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确 认应答号」字段填⼊ client_isn + 1 , 接着把 SYN 和 ACK 标志位置为 1。最后把该 报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。![[Pasted image 20250217171357.png]]
- 客户端收到服务端报⽂后，还要向服务端回应最后⼀个应答报⽂，⾸先该应答报⽂ TCP ⾸部 ACK 标志位置为 1 ，其次「确认应答号」字段填⼊ server_isn + 1 ，最后把报 ⽂发送给服务端，这次报⽂可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。![[Pasted image 20250217171420.png]]
- 服务端收到客户端的应答报⽂后，也进⼊ ESTABLISHED 状态。
**第三次握⼿是可以携带数据的，前两次握⼿是不可以携带数据的**。
#### 如何在 Linux 系统中查看 TCP 状态？
TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。
![[Pasted image 20250217171731.png]]
#### 为什么是三次握⼿？不是两次、四次？
- **三次握⼿才可以阻⽌重复历史连接的初始化（主要原因）**
- **三次握⼿才可以同步双⽅的初始序列号**
- **三次握⼿才可以避免资源浪费**
#### 为什么每次建⽴ TCP 连接时，初始化的序列号都要求不⼀样呢？
- 为了防⽌历史报⽂被下⼀个相同四元组的连接接收（主要⽅⾯）；
- 为了安全性，防⽌⿊客伪造的相同序列号的 TCP 报⽂被对⽅接收；
#### 既然 IP 层会分⽚，为什么 TCP 层还需要 MSS 呢？
**如果在 TCP 的整个报⽂（头部 + 数据）交给 IP 层进⾏分⽚，那么当如果⼀个 IP 分⽚丢失，整个 IP 报⽂的所有分 ⽚都得重传**。
所以，**为了达到最佳的传输效能 TCP 协议在建⽴连接的时候通常要协商双⽅的 MSS 值，经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，进⾏重发时也是以 MSS 为单位，⽽不⽤重 传所有的分⽚**
#### 第⼀次握⼿丢失了，会发⽣什么？
在客户端发送`SYN` 报⽂之后，如果客户端迟迟收不到服务端的 `SYN-ACK `报⽂（第⼆次握⼿），**就会触发「超时重传」机制，重传 SYN 报⽂，⽽且重传的 SYN 报⽂的序列号都是⼀样的**。
在 Linux ⾥，客户端的 SYN 报⽂最⼤重传次数由 tcp_syn_retries 内核参数控制
通常，**每次超时重传的时间是上 ⼀次的 2 倍**。
![[Pasted image 20250217202609.png]]
#### 第⼆次握⼿丢失了，会发⽣什么？
因为第⼆次握⼿报⽂⾥是包含对客户端的第⼀次握⼿的 ACK 确认报⽂，所以，**客户端就会触发超时重传机制，重传 SYN 报⽂**。
如果第⼆次握⼿丢失了，服务端就收不到第三次握⼿，于是**服务端这边会触发超时重 传机制，重传 SYN-ACK 报⽂**。
在 Linux 下，SYN-ACK 报⽂的最⼤重传次数由 tcp_synack_retries 内核参数决定
![[Pasted image 20250217202637.png]]
#### 第三次握⼿丢失了，会发⽣什么？
当第三次握⼿丢失 了，如果服务端那⼀⽅迟迟收不到这个确认报⽂，就会触发超时重传机制，重传 SYN-ACK 报⽂，直到收到第三次握⼿，或者达到最⼤重传次数。
**ACK 报⽂是不会有重传的，当 ACK 丢失了，就由对⽅重传对应的报⽂**。
#### 什么是 SYN 攻击？如何避免 SYN 攻击？
在 TCP 三次握⼿的时候，Linux 内核会维护两个队列，分别是： 半连接队列，也称 SYN 队列； 全连接队列，也称 accept 队列；
![[Pasted image 20250217204955.png]]
SYN 攻击⽅式最直接的表现就会**把 TCP 半连接队列打满，这样当 TCP 半连接队列满了，后 续再在收到 SYN 报⽂就会丢弃**，导致客户端⽆法和服务端建⽴连接。
### 1.3 TCP 连接断开
#### TCP 四次挥⼿过程
TCP 断开连接是通过四次挥⼿⽅式。
双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥⼿的过程如下图：
![[Pasted image 20250217211805.png]]
- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户端进⼊ FIN_WAIT_1 状态。
- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊状态。
- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊`FIN_WAIT_2`状态。
- 等待服务端处理完数据后，也向客户端发送`FIN`报⽂，之后服务端进⼊ LAST_ACK 状 态。
- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态。
- 服务端收到了 ACK 应答报⽂后，就进⼊了 CLOSE 状态，⾄此服务端已经完成连接的关 闭。
- 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSE 状态，⾄此客户端也完成连接的关 闭。
**每个⽅向都需要⼀个 FIN 和⼀个 ACK**。
**主动关闭连接的，才有 TIME_WAIT 状态**。
