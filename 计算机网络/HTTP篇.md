# 1. HTTP常见面试题
![[Pasted image 20250125220553.png]]
### 1.1 HTTP基本概念
#### HTTP是什么
HTTP：超文本传输协议。（**双向协议**）
#### HTTP常见状态码
![[Pasted image 20250125221144.png]]
####  HTTP 常见字段
_Host_ 字段
客户端发送请求时，用来指定服务器的域名。Host: www.A.com

_Content-Length 字段_
服务器在返回数据时，会有 `Content-Length` 字段，表明本次回应的数据长度。Content-Length: 1000
**HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**

_Connection 字段_
`onnection` 字段最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用。（HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。）
![[Pasted image 20250125222010.png]]
HTTP/1.1 版本的默认连接都是长连接，但要指定 `Connection` 首部字段的值为 `Keep-Alive`。   Connection: Keep-Alive

_Content-Type 字段_
`Content-Type` 字段用于服务器回应时，告诉客户端，本次数据是什么格式。
Content-Type: text/html; Charset=utf-8
客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。
```
Accept: */*
```

_Content-Encoding 字段_
`Content-Encoding` 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式          Content-Encoding: gzip
客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。
Accept-Encoding: gzip, deflate
### 1.2 GET与POST
#### GET与POST的区别
根据 RFC 规范：
**GET 的语义是从服务器获取指定的资源**GET 请求的参数位置一般是写在 URL 中
**POST 的语义是根据请求负荷（报文body）对指定的资源做出处理**，POST 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据。
#### GET 和 POST 方法都是安全和幂等的吗？
如果从 RFC 规范定义的语义来看：
**GET 方法就是安全且幂等的，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
**POST是不安全不幂等的，所以浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。
但是开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。
RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。
### 1.3 HTTP缓存技术
#### 缓存的实现方式
对于一些具有重复性的 HTTP 请求，可以把这对「请求-响应」的数据都**缓存在本地**
HTTP 缓存有两种实现方式，分别是**强制缓存和协商缓存**。
#### 强制缓存
强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
size 项中标识的是 from disk cache，就是使用了强制缓存。
![[Pasted image 20250125225457.png]]
强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
- `Cache-Control`， 是一个相对时间；
- `Expires`，是一个绝对时间；
**Cache-Control 的优先级高于 Expires** 。
Cache-control流程：
- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。
#### 协商缓存
在浏览器使用开发者工具的时候，某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源。
**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。
![[Pasted image 20250204092747.png]]
协商缓存可以基于两种头部来实现。
第一种：请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现
- 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
- 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。
第⼆种：请求头部中的 If-None-Match 字段与响应头部中的 ETag 字段
- 响应头部中 Etag ：唯⼀标识响应资源；
- 请求头部中的 If-None-Match ：当资源过期时，浏览器发现响应头⾥有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进⾏⽐对，如果资源没有变化返回 304，如果资源变化了返回 200。
Etag和 Last-Modified同时存在时，**Etag 的优先级更⾼**
**协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使⽤，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。**
![[Pasted image 20250204095810.png]]
### 1.4 HTTP特性
到⽬前为⽌，HTTP 常⻅到版本有 HTTP/1.1，HTTP/2.0，HTTP/3.0。
HTTP 协议是基于 TCP/IP
#### HTTP/1.1 的优点
HTTP 最突出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。
- HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层； 
- HTTP/1.1 和 HTTP/2.0 传输协议使⽤的是 TCP 协议，⽽到了 HTTP/3.0 传输协议改⽤了 UDP 协议。
#### HTTP/1.1 的缺点
HTTP 协议是「⽆状态、明⽂传输」，「不安全」。
对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ Cookie 技术。 Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。
**相当于在客户端第⼀次请求后，服务器会下发⼀个装有客户信息的「⼩贴纸」，后续客户端请求服务器的时候，带上「⼩贴纸」，服务器就能认得了了**
#### HTTP/1.1 的性能
1. 长连接（持久连接）
持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。
如果某个 HTTP ⻓连接超过⼀定时间没有任何数据交互，服务端就会主动断开这个连接。
![[Pasted image 20250204101825.png]]
2. 管道⽹络传输
可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等 其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。
服务器必须按照接收请求的顺序发送对这些管道化请求的响应。
如果服务端在处理 A 请求时耗时⽐较⻓，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。
**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。**
实际上 HTTP/1.1 管道化技术不是默认开启，⽽且浏览器基本都没有⽀持，这个功能基本没有被使用。
### 1.5 HTTP 与 HTTPS
#### HTTP 与 HTTPS的区别
- HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂ 能够加密传输。 
 ![[Pasted image 20250204103232.png]]
- HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。
- 两者的默认端⼝不⼀样，HTTP 默认端⼝号是 80，HTTPS 默认端⼝号是 443。 
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的
#### HTTPS 解决了 HTTP 的哪些问题？
1.  混合加密
通过混合加密的⽅式可以保证信息的机密性，解决了窃听的⻛险。
![[Pasted image 20250204103600.png]]
HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：
- 在通信建⽴前采⽤**⾮对称加密**的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。
- 在通信过程中全部使⽤**对称加密**的「会话秘钥」的⽅式加密明⽂数据。
采⽤「混合加密」的⽅式的原因：
- 对称加密只使⽤⼀个密钥，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。
- ⾮对称加密使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，解决了密钥交换问题但速度慢。
2. 摘要算法 + 数字签名 
在计算机⾥会⽤**摘要算法（哈希函数）来计算出内容的哈希值，这个哈希值是唯⼀的，且⽆法通过哈希值推导出内容。**
![[Pasted image 20250206210138.png]]
通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间⼈替换，因为这⾥缺少对客户端收到的消息是否来源于服务端的证明。**
计算机⾥会⽤**⾮对称加密算法**来解决，共有两个密钥：
- ⼀个是公钥，这个是可以公开给所有⼈的；
- ⼀个是私钥，这个必须由本⼈管理，不可泄露。
这两个密钥可以**双向加解密的**，⽐如可以⽤公钥加密内容，然后⽤私钥解密，也可以⽤私钥 加密内容，公钥解密内容。
- **公钥加密，私钥解密**。这个⽬的是为了**保证内容传输的安全**，因为被公钥加密的内容，其 他⼈是⽆法解密的，只有持有私钥的⼈，才能解密出实际的内容。
- **私钥加密，公钥解密**。这个⽬的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如 果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的⼈发送 的。
⾮对称加密的⽤途主要在于**通过「私钥加密，公钥解密」的⽅式，来确认消息的身份**（能确认消息是由持有私钥的⼀⽅发送的），数字签名算法，就是⽤的是这种⽅式，不过私钥加密内容不是内容本身，⽽是**对内容的哈希值加密**。
![[Pasted image 20250206210919.png]]
私钥是由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。
3. 数字证书
通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险。
![[Pasted image 20250206211654.png]]
#### HTTPS 是如何建⽴连接的？其间交互了什么？
SSL/TLS 协议基本流程：
- 客户端向服务器索要并验证服务器的公钥。
- 双⽅协商⽣产「会话秘钥」。
- 双⽅采⽤「会话秘钥」进⾏加密通信。
前两步也就是 SSL/TLS 的建⽴过程，也就是 TLS 握⼿阶段。
TLS 的「握⼿阶段」涉及**四次**通信，使⽤不同的密钥交换算法，TLS 握⼿流程也会不⼀样 的，现在常⽤的密钥交换算法有两种： **RSA 算法 和 ECDHE 算法。**
基于 RSA 算法的 TLS 握⼿过程：
![[Pasted image 20250206213300.png]]
**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。**
基于 RSA 算法的 HTTPS 存在「前向安全」的问题：如果服务端的私钥泄漏了，过去 被第三⽅截获的所有 TLS 通讯密⽂都会被破解。
为了解决这个问题，后⾯就出现了 ECDHE 密钥协商算法，我们现在⼤多数⽹站使⽤的正是 ECDHE 密钥协商算法。
数字证书签发和验证流程：
![[Pasted image 20250206215243.png]]
证书的验证过程中还存在⼀个**证书信任链**的问题。
![[Pasted image 20250208194019.png]]
操作系统内⼀般会内置⼀些根证书，
#### HTTPS 的应⽤数据是如何保证完整性的？
TLS 在实现上分为**握⼿协议**和**记录协议**两层：
- TLS 握⼿协议就是我们前⾯说的 TLS 四次握⼿的过程，负责协商加密算法和⽣成对称密 钥，后续⽤此密钥来保护应⽤程序数据（即 HTTP 数据）；
- TLS 记录协议负责保护应⽤程序数据并验证其完整性和来源，所以对 HTTP 数据加密是 使⽤记录协议；
TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证，过程如下图：![[Pasted image 20250206224310.png]]
经过压缩的⽚段会被加上**消息认证码（MAC 值，这个是通过哈希算法⽣成 的），这是为了保证完整性，并进⾏数据的认证**。通过附加消息认证码的 MAC 值，可以 识别出篡改。
经过压缩的⽚段再加上消息认证码会⼀起通过对称密码进⾏加密。
**HTTPS 协议本身到⽬前为⽌还是没有任何漏洞的**，即使你成功进⾏中间⼈攻击，本质 上是利⽤了客户端的漏洞（⽤户点击继续访问或者被恶意导⼊伪造的根证书），并不是 HTTPS 不够安全。
### 1.6 HTTP/1.1、HTTP/2、HTTP/3 演变
#### HTTP/2做的优化
HTTP/2 协议是基于 HTTPS 的
![[Pasted image 20250206225534.png]]
那 HTTP/2 相⽐ HTTP/1.1 性能上的改进：
1. 头部压缩：HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分（HPACK算法）
2. 二进制格式：HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了**⼆进制格式**，头信息和数据体都是⼆进制，并且统称为帧：**头信息桢和数据帧**。（增加数据传输的效率）![[Pasted image 20250207152552.png]]
3. 并发传输：引出了 Stream 概念，多个 Stream 复⽤在⼀条 TCP 连接。（解决了 HTTP/1 队头阻塞的问题）
![[Pasted image 20250207153334.png]]
**针对不同的 HTTP 请求⽤独⼀⽆⼆的 Stream ID 来区分，接收端可以通过 Stream ID 有序组 装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也 就是 HTTP/2 可以并⾏交错地发送请求和响应。**
4. 服务器推送
服务端不再是被动地响应，可以**主动向客户端发送消息**。
客户端和服务器**双⽅都可以建⽴ Stream**， Stream ID 也是有区别的，客户端建⽴的 Stream 必须是奇数号，⽽服务器建⽴的 Stream 必须是偶数号。
	HTTP/2的缺陷
HTTP在TCP层也有“队头阻塞”的问题。
**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节 数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个 字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节 数据到达时，HTTP/2 应⽤层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**
![[Pasted image 20250207160713.png]]⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来。**
#### HTTP/3做的优化
**HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**。
![[Pasted image 20250207161045.png]]
UDP 是不可靠的传输，但基于 UDP 的 **QUIC 协议**可以实现类似 TCP 的可靠性传输。
QUIC的特点：
1. ⽆队头阻塞：**当某个流发⽣丢包时，只会阻塞这个流， 其他流不会受到影响，因此不存在队头阻塞问题**。这与 HTTP/2 不同，HTTP/2 只要某个流中 的数据包丢失了，其他流也会因此受影响。![[Pasted image 20250207161335.png]]
2. 更快的连接建⽴：![[Pasted image 20250207162028.png]]
3. 连接迁移：QUIC 协议没有⽤四元组的⽅式来“绑定”连接，⽽是通过**连接ID**来标记通信的两个端点，因此即使移动设备的⽹络变化后，导致 IP 地址变化了，只要仍保有上下⽂信息（⽐如连接 ID、TLS 密钥等），就可以“⽆缝”地复⽤原 连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。
# 2. HTTP/1.1的优化
![[Pasted image 20250207162954.png]]
### 2.1 如何避免发送 HTTP 请求？
缓存技术
客户端会把第⼀次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，⽽ 响应作为 value，两者形成映射关系。这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响 应，如果找到了，就直接从本地读取该响应。
![[Pasted image 20250207164233.png]]
![[Pasted image 20250207164351.png]]
### 2.2 如何减少 HTTP 请求次数？
#### 减少重定向请求次数、
如果重定向请求越多，那么客户端就要多次发起 HTTP 请求，每⼀次的 HTTP 请求都 得经过⽹络。
此外，服务端这⼀⽅往往不只有⼀台服务器，⽐如源服务器上⼀级是代理服务器，然后代理服务器才与客户端通信![[Pasted image 20250207165718.png]]
**重定向的⼯作交由代理服务器完成，就能减少 HTTP 请求次数了**
![[Pasted image 20250207165812.png]]
当代理服务器知晓了重定向规则后，可以进⼀步减少消息传递次数![[Pasted image 20250207165829.png]]
#### 合并请求
把多个访问⼩⽂件的请求合并成⼀个⼤的请求，**减少了重复发送的 HTTP 头部**。
为了防⽌单个请求的阻塞，所以**⼀般浏览器会同时 发起 5-6 个请求，每⼀个请求都是不同的 TCP 连接，那么如果合并了请求，也就会减少 TCP 连接的数量，因⽽省去了 TCP 握⼿和慢启动过程耗费的时间。**
**通过将多个⼩图⽚合并成⼀个⼤图⽚来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从⽽减少⽹络的开销**。
**合并请求的⽅式就是合并资源，以⼀个⼤资源的请求替换多个⼩资源的请求。**
问题：**当⼤资源中的某⼀个⼩资源发⽣变化后，客户端必须 重新下载整个完整的⼤资源⽂件**。
#### 延迟发送请求
**「按需获取」**：请求⽹⻚的时候，没必要把全部资源都获取到，⽽是只获取当前⽤户所看到的⻚⾯资源，当 ⽤户向下滑动⻚⾯的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。
### 2.3 如何减少 HTTP 响应的数据⼤⼩？
**压缩响应数据的大小**
#### 无损压缩
⽆损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样。
gzip ,Google 推出的 Brotli 算法就是⽐较常⻅的⽆损压缩。
客户端⽀持的压缩算法，会在 HTTP 请求中通过头部中的 `Accept-Encoding `字段告诉服务器。
服务器通过响应头部中的` Content-Encoding` 字段告诉客户端该资源使⽤ 的压缩算法。
#### 有损压缩
经过此⽅法压缩，解压的数据会与原始数据不同但是⾮常 接近。
可以通过 HTTP 请求头部中的 `Accept` 字段⾥的「 q 质量因⼦」，告诉服务器期望的资源质量。
```
Accept: audio/*; q=0.2, audio/basic
```
关于图⽚的压缩，⽬前压缩⽐较⾼的是 Google 推出的 **WebP 格式**
# 3. HTTPS RSA 握⼿解析
![[Pasted image 20250207173853.png]]
### 3.1 TLS握手过程
![[Pasted image 20250208191832.png]]
**通常经过「四个消息」就可以完成 TLS 握⼿，也就是需要 2个 RTT 的时延**
### 3.2 RSA握手过程
![[Pasted image 20250208192856.png]]
![[Pasted image 20250208192906.png]]
#### TLS 第⼀次握⼿
客户端⾸先会发⼀个**Client Hello**消息。
消息里⾯有客户端使⽤的 TLS 版本号、⽀持的密码套件列表，以及⽣成的**随机数（Client Random）**，这个随机数会被服务端保留。
#### TLS 第⼆次握⼿
当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否⽀持，和从密码套件列表中选择⼀个密码套件，以及⽣成**随机数（Server Random）**。
返回「Server Hello」消息，消息里⾯有服务器确认的 TLS 版本号，也给出了随机数 （Server Random），然后从客户端的密码套件列表选择了⼀个合适的密码套件。
密码套件是比如 ：“Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。基本的形 式**是「密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法」**
然后，服务端为了证明⾃⼰的身份，会**发送「Server Certificate」给客户端**，这个消息里含有数字证书。
随后，**服务端发了「Server Hello Done」消息**，⽬的是告诉客户端本次打招呼完毕。
#### TLS第三次握手
客户端就会⽣成⼀个新的**随机数 (pre-master)**，⽤服务器的 RSA 公钥加密该随机 数，**通过「Client Key Exchange」消息传给服务端。**
服务端收到后，⽤ RSA 私钥解密，得到客户端发来的随机数 (pre-master)。
**客户端和服务端双⽅都共享了三个随机数，分别是 Client Random、Server Random、pre-master。**
双⽅根据已经得到的三个随机数，⽣成**会话密钥（Master Secret）**，它是对称密钥， ⽤于对后续的 HTTP 请求/响应的数据加解密。
⽣成完「会话密钥」后，然后**客户端发⼀个「Change Cipher Spec」**，告诉服务端开始使⽤加密⽅式发送消息。
然后，**客户端再发⼀个「Encrypted Handshake Message（Finishd）」消息**，把之前所有发送的数据做个**摘要**，再⽤会话密钥（master secret）加密⼀下，让服务器做个验证，验证 加密通信「是否可⽤」和「之前握⼿信息是否有被中途篡改过」。
「Change Cipher Spec」之前传输的 TLS 握⼿数据都是明⽂，之后都是对称密钥加密的密⽂。
#### TLS 第四次握⼿
服务器也是同样的操作，**发「Change Cipher Spec」和「Encrypted Handshake Message」消息**，如果双⽅都验证加密和解密没问题，那么握⼿正式完成。 最后，就⽤「会话密钥」加解密 HTTP 请求和响应了。
### 3.3 RSA算法的缺陷
使⽤ RSA 密钥协商算法的最⼤问题是不⽀持前向保密。
基于 RSA 算法的 HTTPS 存在「前向安全」的问题：如果服务端的私钥泄漏了，过去 被第三⽅截获的所有 TLS 通讯密⽂都会被破解。
# 4. HTTPS ECDHE 握⼿解析
![[Pasted image 20250208200329.png]]

### 4.1 ECDHE 握⼿过程
**ECDHE 相⽐ RSA 握⼿过程省去了⼀个消息往返的时间。客户端可以在 TLS 协议的第 3 次握⼿后，第 4 次握⼿ 前，发送加密的应⽤数据，以此将 TLS 握⼿的消息往返由 2 RTT 减少到 1 RTT**，⽽对于 RSA 握⼿过程，必须要完成 TLS 四次握⼿，才能传输应⽤数据。
#### TLS 第⼀次握⼿
客户端⾸先会发⼀个「**Client Hello**」消息，消息⾥⾯有客户端使⽤的 TLS 版本号、⽀持的密码套件列表，以及⽣成的**随机数（Client Random）**。
#### TLS 第⼆次握⼿
服务端会返回「**Server Hello**」消息，消息里⾯有服务器确认的 TLS 版本号，也给出了⼀个**随机数（Server Random）**，然后从客户端的密码套件列表选择了⼀个合适的密码套件（这次的密码套件和RSA不一样）。
接着，服务端发送「**Certificate**」消息，会把证书也发给客户端。
这⼀步就和 RSA 握⼿过程有很⼤的区别了，因为服务端选择了 ECDHE 密钥协商算法，所以 会在发送完证书后，发送「**Server Key Exchange**」消息，将椭圆曲线公钥传递给客户端。
这个过程服务器做了三件事：
- 确定好椭圆曲线
- 生成随机数作为服务端私钥并保留本地
- 计算出服务端椭圆曲线公钥，公开给客户端
随后，就是「**Server Hello Done**」消息。
⾄此，TLS 两次握⼿就已经完成了。⽬前客户端和服务端通过明⽂共享了这⼏个信息：**Client Random、Server Random 、使⽤的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥**
#### TLS 第三次握⼿
客户端收到了服务端的证书后校验证书是否合法。
客户端会⽣成⼀个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前⾯给的信息，⽣ **成客户端的椭圆曲线公钥**，然后⽤「**Client Key Exchange**」消息发给服务端。
**最终的会话密钥，就是⽤「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密 钥） 」三个材料⽣成的。**
算好会话密钥后，客户端会发⼀个「**Change Cipher Spec**」消息，告诉服务端后续改⽤对称 算法加密通信。
接着，客户端会发「**Encrypted Handshake Message**」消息，把之前发送的数据做⼀个摘 要，再⽤对称密钥加密⼀下，让服务端做个验证，验证下本次⽣成的对称密钥是否可以正常 使⽤
#### TLS 第四次握⼿
服务端也会有⼀个同样的操作，发「**Change Cipher Spec」和「Encrypted Handshake Message**」消息，如果双⽅都验证加密和解密没问题，那么握⼿正式完成。于 是，就可以正常收发加密的 HTTP 请求和响应了。
#### 总结
RSA 和 ECDHE 握⼿过程的区别：
- RSA 密钥协商算法「不⽀持」前向保密，ECDHE 密钥协商算法「⽀持」前向保密；
- 使⽤了 RSA 密钥协商算法，TLS 完成四次握⼿后，才能进⾏应⽤数据传输，⽽对于 ECDHE 算法，客户端可以不⽤等服务端的最后⼀次 TLS 握⼿，就可以提前发出加密的 HTTP 数据，节省了⼀个消息的往返时间；
- 使⽤ ECDHE， 在 TLS 第 2 次握⼿中，会出现服务器端发出的「Server Key Exchange」 消息，⽽ RSA 握⼿过程没有该消息；
# 5. HTTPS 如何优化？
![[Pasted image 20250208212037.png]]
### 5.1 分析性能损耗
产⽣性能消耗的两个环节：
- TLS 协议握⼿过程；
- 握⼿后的对称加密报⽂传输。(性能消耗很小)
### 5.2 硬件优化
**HTTPS 协议是计算密集型，⽽不是 I/O 密集型**
优化CPU
### 5.3 软件优化
⼀个是软件升级，⼀个是协议优化。
### 5.4协议优化
1. 密钥交换算法优化：选⽤ ECDHE 密钥交换算法替换 RSA 算法
2. TLS升级：TLS 1.3完成 TLS 握⼿只要 1 RTT。**TLS 1.3 把 Hello 和公钥交换这两个消 息合并成了⼀个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握⼿，对于密钥交换算法，废除了不⽀持前向安全性的 RSA 和 DH 算法，只⽀持 ECDHE 算法**。
### 5.5会话复用：
#### Session ID
**客户端和服务器⾸次 TLS 握⼿连接后，双⽅会在内存缓存会话密 钥，并⽤唯⼀的 Session ID 来标识，Session ID 和会话密钥相当于 key-value 的关系**。当客户端再次连接时，hello 消息⾥会带上 Session ID，服务器收到后就会从内存找，如果找 到就直接⽤该会话密钥恢复会话状态，跳过其余的过程，内存中的会话密钥会定期失效。![[Pasted image 20250215152627.png]]
缺点：
1. 服务器必须保持每⼀个客户端的会话密钥，随着客户端的增多，**服务器的内存压⼒也会越⼤**。
2. 现在⽹站服务⼀般是由多台服务器通过负载均衡提供服务的，**客户端再次连接不⼀定会命中上次访问过的服务器**，于是还要⾛完整的 TLS 握⼿过程；
#### Session Ticket
**服务器不再缓存每个客户端的会话 密钥，⽽是把缓存的⼯作交给了客户端**。
客户端与服务器⾸次建⽴连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给 客户端缓存该 Ticket。
客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上⼀次的会话密 钥，然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。
![[Pasted image 20250215153812.png]]对于集群服务器的话，**要确保每台服务器加密 「会话密钥」的密钥是⼀致的**。
Session ID 和 Session Ticket 都不具备前向安全性。
#### Pre-shared Key
TLS1.3 更为⽜逼，对于重连 TLS1.3 只需要 0 RTT，在重连时，客户端会把 Ticket 和 HTTP 请求⼀同发送给服务端，这种⽅式叫 **Pre-shared Key**。
# 6. HTTP/2 ⽜逼在哪？
![[Pasted image 20250215154240.png]]
### 6.1 头部压缩
对于 Body 部分，HTTP/1.1 协议可以使 ⽤头字段 「Content-Encoding」指定 Body 的压缩⽅式，但是没有办法压缩Header。
HTTP/2使用**HPACK**算法压缩头部，HPACK 算法主 要包含三个组成部分：
- 静态字典：HTTP/2 为⾼频出现在头部的字符串和字段建⽴了⼀张静态表
- 动态字典：不在静态表范围内的头部字符串就要⾃⾏构建**动态表**，会在编码解码的时候随时更新。⽐如，第⼀次发送时头部中的「 User-Agent 」字段数据有上百个字节，经过 Huffman 编码 发送出去后，客户端和服务器双⽅都会更新⾃⼰的动态表，添加⼀个新的 Index 号 62。**那么 在下⼀次发送的时候，就不⽤重复发这个字段的数据了，只⽤发 1 个字节的 Index 号就好 了，因为双⽅都可以根据⾃⼰的动态表获取到字段的数据**。使得动态表⽣效有⼀个前提：**必须同⼀个连接上，重复传输完全相同的 HTTP 头部**。
- Huffman 编码（压缩算法）；

### 6.2 ⼆进制帧
将 HTTP/1 的⽂本格式改成⼆进制格式传输数据，头信息和数据体都是⼆进制，并且统称为帧：**头信息桢和数据帧**。（增加数据传输的效率）
![[Pasted image 20250215155821.png]]
HTTP/2 ⼆进制帧的结构如下图：![[Pasted image 20250215165146.png]]
帧⻓度后⾯的⼀个字节是表示**帧的类型，⼀般分为数据 帧和控制帧两类**。![[Pasted image 20250215165505.png]]
帧类型后⾯的⼀个字节是**标志位**，
### 6.3 并发传输
通过 Stream 这个设计，**多个 Stream 复⽤⼀条 TCP 连接，达到并发的效果**，解决了 HTTP/1.1 队头阻塞的问题。
![[Pasted image 20250215160307.png]]
- 1 个 TCP 连接包含⼀个或者多个 Stream
- Stream ⾥可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；
- Message ⾥包含⼀条或者多个 Frame，Frame 是 HTTP/2 最⼩单位，以⼆进制压缩格式存放 HTTP/1 中的内容（头部和包体）；
总结：多个 Stream 跑在⼀条 TCP 连接，同⼀个 HTTP 请求与响应是跑在同⼀个 Stream 中，HTTP 消息可以由多个 Frame 构成，⼀个 Frame 可以由多个 TCP 报⽂构成。
**针对不同的 HTTP 请求⽤独⼀⽆⼆的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，⽽同⼀ Stream 内部的帧必须是严格有序的，因此可以并发不同的 Stream ，也 就是 HTTP/2 可以并⾏交错地发送请求和响应。![[Pasted image 20250215161015.png]]
客户端和服务器双⽅都可以建⽴ Stream**，因为服务端可以主动推送资源给客户端， 客户端 建⽴的 Stream 必须是奇数号，⽽服务器建⽴的 Stream 必须是偶数号。
![[Pasted image 20250215161352.png]]
HTTP/2 还可以对每个 Stream 设置不同**优先级**。
### 6.4 服务器主动推送资源
![[Pasted image 20250215163342.png]]
![[Pasted image 20250215163434.png]]
	HTTP/2的缺陷
1. HTTP在TCP层也有“队头阻塞”的问题。
**HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节 数据是完整且连续的，这样内核才会将缓冲区⾥的数据返回给 HTTP 应⽤，那么当「前 1 个 字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区⾥，只有等到这 1 个字节 数据到达时，HTTP/2 应⽤层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。**
![[Pasted image 20250207160713.png]]⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。
2. TCP 与 TLS 的握⼿时延迟
3. ⽹络迁移需要重新连接
# 7. HTTP/3
![[Pasted image 20250215163916.png]]
**HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**。
![[Pasted image 20250207161045.png]]
UDP 是不可靠的传输，但基于 UDP 的 **QUIC 协议**可以实现类似 TCP 的可靠性传输。
### 7.1 QUIC协议的特点
#### 无队头阻塞
 **当某个流发⽣丢包时，只会阻塞这个流， 其他流不会受到影响，因此不存在队头阻塞问题**。这与 HTTP/2 不同，HTTP/2 只要某个流中 的数据包丢失了，其他流也会因此受影响。![[Pasted image 20250207161335.png]]
#### 更快的连接建立
HTTP/3 在传输数据前虽然需要 QUIC 协议握⼿，这个握⼿过程只需要 1 RTT，握⼿的⽬的是 为确认双⽅的「连接 ID」。
**HTTP/3 的 QUIC 协议并不是与 TLS 分层，⽽是 QUIC 内部包含了 TLS，它在⾃⼰的帧 会携带 TLS ⾥的“记录”，再加上 QUIC 使⽤的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同 时」完成建⽴连接与密钥协商，甚⾄在第⼆次连接的时候，应⽤数据包可以和 QUIC 握⼿信 息（连接信息 + TLS 信息）⼀起发送，达到 0-RTT 的效果**。
![[Pasted image 20250207162028.png]]
#### 连接迁移
QUIC 协议没有⽤四元组（源 IP、源端⼝、⽬ 的 IP、⽬的端⼝）的⽅式来“绑定”连接，⽽是通过**连接ID**来标记通信的两个端点，因此即使移动设备的⽹络变化后，导致 IP 地址变化了，只要仍保有上下⽂信息（⽐如连接 ID、TLS 密钥等），就可以“⽆缝”地复⽤原 连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。
### 7.2 HTTP/3 协议
HTTP/3 协议在 HTTP 这⼀层做的变化：
HTTP/3 的帧的结构也变简单了![[Pasted image 20250215165834.png]]
HTTP/3 的头部压缩算法升级成了**QPACK**。
**动态表是具有时序性的，如果⾸次出现的请求发⽣了丢包，后续的收到请求，对 ⽅就⽆法解码出 HPACK 头部，因为对⽅还没建⽴好动态表，因此后续的请求解码会阻塞到 ⾸次请求中丢失的数据包重传过来**。
QUIC 会有两个特殊的单向流，是⽤来**同步双⽅的动态表**。
# 8. HTTP 协议与RPC
**基于 TCP，就衍⽣了⾮常多的协议，⽐如 HTTP 和 RPC**。
### 8.1 HTTP和RPC
![[Pasted image 20250216175459.png]]
**RPC：远程过程调⽤，不是一个具体的协议，而是一种调用方式**。像 gRPC 和 Thrift 这样的具体实现，才 是协议，它们是实现了 RPC 调⽤的协议。⽬的是希望程序员能像调⽤本地⽅法那样去调 ⽤远端的服务⽅法
![[Pasted image 20250216180920.png]]
![[Pasted image 20250216180900.png]]
**虽然⼤部分 RPC 协议底层使⽤ TCP，但实际上它们不⼀定⾮得使⽤ TCP， 改⽤ UDP 或者 HTTP，其实也可以做到类似的功能**。
HTTP 主要⽤于 B/S 架构，⽽ RPC 更多⽤于 C/S 架构。但现在其实 已经没分那么清了，B/S 和 C/S 在慢慢融合
### 8.2 HTTP和RPC的区别
#### 服务发现
建⽴连接的前提是知道 **IP 地址和 端⼝**。这个找到服务对应的 IP 端⼝的过程，其实就是**服务发现**。
- HTTP中，已知服务器的域名，可以通过**DNS服务**去解析得到IP地址，默认80端口。
- RPC中，会有专⻔的**中间服务去保存服务名和IP信息**，如**Consul、Etcd、Redis、CoreDNS**。
#### 底层连接方式
**RPC 协议也是通过建⽴ TCP ⻓链接进⾏数据交互，但是RPC 协议⼀般还会再建个连接池，在请求量⼤的时候，建⽴多条连接放在池内，要发数 据的时候就从池⾥取⼀条连接出来，⽤完放回去，下次再复⽤，有利于提升⽹络请求性能**。![[Pasted image 20250216182425.png]]
#### 传输的内容
基于 TCP 传输的消息，**都是消息头 Header 和消息体 Body**。
**Body的内容只能是⼆进制 01 串，将结构体转换为二进制01串的方案有：Json、Protobuf等**。
将结构体转为⼆进制数组的过程就叫**序列化**，将⼆进制数组复原成结构体的过程 叫**反序列化**。
![[Pasted image 20250216183418.png]]
**HTTP/1.1在Body中，使用Json来序列化结构体数据**。
**RPC可以采⽤体积更⼩的 Protobuf 或其他序列化协议，性能更好**
![[Pasted image 20250216183814.png]]
HTTP/2 在前者的基础上做 了很多改进，所以**性能可能⽐很多 RPC 协议还要好，甚⾄连 gRPC 底层都直接⽤的 HTTP/2** 。
# 9.  HTTP 协议与WebSocket
### 9.1 使⽤ HTTP 不断轮询
**怎么样才能在⽤户不做任何操作的情况下，⽹⻚能收到消息并发⽣变更。最常⻅的解决⽅案是，⽹⻚的前端代码⾥不断定时发 HTTP 请求到服务器，服务器收到请求 后给客户端响应消息**。常见的是扫码登陆。
### 9.2 长轮询
HTTP 请求发出后，⼀般会给服务器留⼀定的时间做响应，⽐如 3 秒，规定时间内没返回，就认为是超时。
**如果我们的 HTTP 请求将超时设置的很⼤，⽐如 30 秒，在这 30 秒内只要服务器收到了扫码 请求，就⽴⻢返回给客户端⽹⻚。如果超时，那就⽴⻢发起下⼀次请求**。
![[Pasted image 20250216213107.png]]
这种发起⼀个请求，在较⻓时间内等待服务器响应的机制，就是所谓的**⻓训轮机制**。
### 9.3 WebSocket
**应⽤层协议WebSocket是另外⼀个基于TCP的新协议**。
![[Pasted image 20250216213438.png]]
#### 怎么建⽴WebSocket连接
浏览器在 TCP 三次握⼿建⽴连接之后，都统⼀使⽤ HTTP 协议先进 ⾏⼀次通信。
- 如果此时是普通的 HTTP 请求，那后续双⽅就还是⽼样⼦继续⽤普通 HTTP 协议进⾏交互
- 如果这时候是想建⽴ WebSocket 连接，就会在 HTTP 请求⾥带上⼀些特殊的header 头，如下：
```
Connection: Upgrade //浏览器想升级协议
Upgrade: WebSocket //升级成WebSocket
Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n //随机生成的base64码
```
如果服务器正好⽀持升级成 WebSocket 协议。就会⾛ WebSocket 握⼿流程，同时根据客户端⽣成的 base64 码，⽤某个公开的算法变成另⼀段字符串，放在 HTTP 响应的 WebSocket-Accept 头⾥，同时带上 101状态码（指协议切换） ，发回给浏览器。HTTP 的响应如下：
```
HTTP/1.1 101 Switching Protocols\r\n 
Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n 
Upgrade: WebSocket\r\n 
Connection: Upgrade\r\n
```
之后，浏览器也⽤同样的公开算法将 base64码 转成另⼀段字符串，如果这段字符串跟服务器 传回来的字符串⼀致，那验证通过。![[Pasted image 20250216215207.png]]
就这样经历了⼀来⼀回两次 HTTP 握⼿，WebSocket就建⽴完成了，后续双⽅就可以使⽤ webscoket 的数据格式进⾏通信了。
**经历了三次TCP握⼿之后，利⽤ HTTP 协议升级为 WebSocket 协议。WebSocket只有在建⽴连接时才⽤到了HTTP，升级完成之后就跟HTTP没有任何关系了**。
#### WebSocket的消息格式
数据包在WebSocket中被叫做**帧**。
**WebSocket的数据格式也是数据头（内含payload⻓度） + payload data 的形式**。
#### WebSocket的使⽤场景
WebSocket完美继承了 TCP 协议的全双⼯能⼒，**适⽤于需要服务器和客户端（浏览器）频繁交互的⼤部分场景**。