计网八股参考网站[(https://xiaolincoding.com/)](https://xiaolincoding.com/)
## 1. TCP/IP 网络模型的层
TCP/IP 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。
![[Pasted image 20250119172346.png]]
![[Pasted image 20250119172412.png]]

#### 1.1 应用层
我们能直接接触到的就是 **应用层** ，我们电脑或手机使用的应用软件都是在应用层实现。
当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。
应用层只需要专注于为用户提供应用功能
#### 1.2 传输层
应用层的数据包会传给传输层，**传输层**（_Transport Layer_）是为应用层提供网络支持的。
在传输层会有两个传输协议，分别是 TCP 和 UDP。
当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。
#### 1.3 网络层
网络层承担实际传输的功能。
网络层最常使用的是 IP 协议（_Internet Protocol_）。我们一般用 IP 地址给设备进行编号。
需要将 IP 地址分成两种意义：
- 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- 一个是**主机号**，负责标识同一「子网」下的不同主机；
需要配合**子网掩码**才能算出 IP 地址 的网络号和主机号。
举个例子，比如 10.100.122.0/24，后面的`/24`表示就是`255.255.255.0` 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。
将 10.100.122.2 和 255.255.255.0 进行**按位与运算**，就可以得到网络号。
将 255.255.255.0 取反后与IP地址进行进行**按位与运算**，就可以得到主机号。
**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。**
#### 1.4 网络接口层
生成了 IP 头部之后，接下来要交给**网络接口层**（_Link Layer_）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。
MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。
## 2. 基础定义
#### 2.1 HTTP
![[Pasted image 20250121191901.png]]
![[Pasted image 20250121191912.png]]
当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html`
![[Pasted image 20250121192028.png]]
#### 2.2 真实地址查询——DNS
`DNS` 服务器：专门保存了 `Web` 服务器域名与 `IP` 的对应关系的服务器
DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com.`，**越靠右**的位置表示其层级**越高**（最后一个.可以省略，代表根域名）。
域名的层级关系类似一个树状结构：
- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）
![[Pasted image 20250121192740.png]]浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。
#### 2.3 协议栈
协议栈的内部上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。
![[Pasted image 20250121193006.png]]
IP 中还包括 `ICMP` 协议和 `ARP` 协议。
- `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
- `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。
#### 2.4 TCP
HTTP 是基于 TCP 协议传输的。
TCP 报文头部的格式：![[Pasted image 20250121193521.png]]
**序号**用来解决包的乱序问题。
**确认号**目的是确认发出去对方是否有收到。
**状态位**：这些带状态位的包的发送，会引起双方的状态变更。如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接。
**窗口大小**：用于声明窗口（缓存大小），TCP用于**流量控制**。
TCP会做**拥塞控制**。
**TCP 传输数据之前，要先三次握手建立连接**
在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为**三次握手**，目的是**保证双方都有发送和接收的能力**。
![[Pasted image 20250121194152.png]]
TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。
先是服务端主动监听某个端口，处于 `LISTEN` 状态。
如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。
![[Pasted image 20250121195514.png]]
![[Pasted image 20250121195545.png]]
TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。
在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。
网络包的报文：![[Pasted image 20250121200329.png]]
#### 2.5 远程定位——IP
TCP 模块需要委托 IP 模块将数据封装成**网络包**。
 IP 报文头部的格式：
 ![[Pasted image 20250121201128.png]]
 - 源地址IP，即是客户端输出的 IP 地址；
 - 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。
 HTTP 是经过 TCP 传输的，所以在 IP 包头的**协议号**，要填写为 `06`（十六进制），表示协议为 TCP。
 当存在多个网卡时，需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。
 在 Linux 操作系统，我们可以使用 `route -n` 命令查看当前系统的路由表。
 ![[Pasted image 20250121204413.png]]
 第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。
 网络包的报文:
 ![[Pasted image 20250121204708.png]]
 #### 2.5 两点传输 —— MAC
 MAC 头部是以太网使用的头部：![[Pasted image 20250121204833.png]]
 一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：
 - `0800` ： IP 协议
 - `0806` ： ARP 协议
 **发送方**的 MAC 地址：网卡的ROM包含。
应该把网络包发送给**路由表**相匹配的条目中`Gateway` 列中的 IP 地址。
![[Pasted image 20250121210533.png]]
操作系统会把查询结果放到一块叫做 **ARP 缓存**的内存空间，缓存的时间就几分钟。
在发包时：
- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。
在 Linux 系统中，我们可以使用`arp -a` 命令来查看 ARP 缓存的内容。
![[Pasted image 20250121211032.png]]
#### 2.6 出口 —— 网卡
网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。
- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏
![[Pasted image 20250121211922.png]]
#### 2.7 交换机
交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。
交换机里的模块进行接收到达网线接口的电信号并转换为数字信号，通过包末尾的 `FCS` 校验错误，如果没问题则放到缓冲区。
**计算机的网卡本身具有 MAC 地址**，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃。
**交换机的端口不具有 MAC 地址**，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。
交换机的 MAC 地址表主要包含两个信息：
- 一个是设备的 MAC 地址
- 另一个是该设备连接在交换机的哪个端口上。
![[Pasted image 20250121215333.png]]
**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。
若地址表中找不到指定的 MAC 地址，交换机只能将包转发到除了源端口之外的所有端口上。
以太网的设计本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。
如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。
#### 2.8 路由器
**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址。
**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。
当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。
路由器的包接收操作：通过包末尾的 `FCS` 进行错误校验。如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。
查询路由表确定输出端口：
完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部（**MAC 头部的作用就是将包送达路由器**）。
接下来进行转发操作，首先是查询路由表判断转发方向
![[Pasted image 20250122193920.png]]
路由器的包的发送操作：
首先，根据**路由表的网关列**判断对方的地址。如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。
知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。路由器也有 ARP 缓存。
接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。
发送出去的网络包会通过**交换机**到达下一个路由器。
在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。
#### 2.9 服务器 与 客户端
![[Pasted image 20250122194958.png]]
![[Pasted image 20250122201530.png]]
## 3. Linux如何收发网络包
#### 3.1 Linux网络协议栈
 ![[Pasted image 20250122203019.png]]
#### 3.2 Linux 接收网络包的流程
 **NAPI 机制**：**不采用中断的方式读取数据**，首先采用中断唤醒数据接收的服务程序，然后 `poll` 的方法来轮询数据。
 当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。
 硬件中断处理函数会做如下的事情：
 - 需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。
 - 接着，发起「软中断」，然后恢复刚才屏蔽的中断。
至此，硬件中断处理函数的工作就已经完成。
软中断的处理：当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。
网络协议栈：![[Pasted image 20250125161713.png]]
传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的Socket，并把数据放到 Socket 的接收缓冲区。
应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。
#### 3.4 Linux 发送网络包的流程
发送网络包的流程正好和接收流程相反。
应用程序会调用 Socket 发送数据包的接口，会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，**将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区**。
接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理。
如果使用的是 TCP ，**先拷贝一个新的 sk_buff 副本** ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。
接着，对 sk_buff 填充 TCP 头。（sk_buff 可以表示各个层的数据包）
为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包。是通过调整 sk_buff 中 `data` 的指针做到的。
- 当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐步剥离协议首部。
- 当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb->data 的值来增加协议首部。
当发送报文时，data 指针的移动过程：
![[Pasted image 20250125164318.png]]
至此传输层工作完成。
网络层、网络接口层依次完成任务后，会触发「软中断」告诉网卡驱动程序这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。
射到网卡可访问的内存 DMA 区域，最后触发真实的发送。最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。
发送网络数据的时候，涉及几次内存拷贝操作？：