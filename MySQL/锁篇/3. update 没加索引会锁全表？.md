# update 没加索引会锁全表？
## 为什么会发生这种的事故？
**在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了**。
这里有一张数据库表，其中 id 为主键索引。
![[Pasted image 20250318094732.png]]
假设有两个事务的执行顺序如下：
![[Pasted image 20250318094654.png]]
这次事务 B 的 update 语句被阻塞了。这是因为事务 A 的 update 语句中 where 条件没有索引列，触发了全表扫描，在扫描过程中会对索引加锁，所以全表扫描的场景下，所有记录都会被加锁，也就是这条 update 语句产生了 4 个记录锁和 5 个间隙锁，相当于锁住了全表。
![[Pasted image 20250318094758.png]]
update 语句的 where 带上索引也不能避免全表记录加锁。**关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了**。
## 如何避免这种事故的发生？
可以将 MySQL 里的 `sql_safe_updates` 参数设置为 1，开启安全更新模式。
大致的意思是，当 sql_safe_updates 设置为 1 时。
update 语句必须满足如下条件之一才能执行成功：
- 使用 where，并且 where 条件中必须有索引列；
- 使用 limit；
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列；
delete 语句必须满足以下条件能执行成功：
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列；
如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 `force index([index_name])` 可以告诉优化器使用哪个索引。
