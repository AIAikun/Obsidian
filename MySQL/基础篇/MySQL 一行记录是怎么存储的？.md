# MySQL 一行记录是怎么存储的？
## MySQL 的数据存放在哪个文件？
MySQL 的数据都是保存在磁盘的。
MySQL 存储的行为是由存储引擎实现的，InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎。
``` sql
mysql> SHOW VARIABLES LIKE 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
1 row in set (0.00 sec)
```
我们每创建一个 database（数据库）都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。
![[Pasted image 20250305212907.png]]
可以看到，共有三个文件，这三个文件分别代表着：
 - db.opt
 - t_order.frm，t_order 的**表结构**会保存在这个文件
 - t_order.ibd，t_order 的**表数据**会保存在这个文件。这个文件也称为独占表空间文件。
### 表空间文件的结构是怎么样的？
 **表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB 存储引擎的逻辑存储结构大致如下图：![[Pasted image 20250305213144.png]]
#### 1 行（row）
#### 2、页（page）
**InnoDB 的数据是按「页」为单位来读写的，默认每个页的大小为 16KB**。
页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。
#### 3、区（extent）
 InnoDB 存储引擎是用 B+ 树来组织数据的。
 **在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于  16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**。
#### 4. 段（segment）
表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。
- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合。
## InnoDB 行格式有哪些？
行格式（row_format），就是一条记录的存储结构。InnoDB 主要用的是Compact、Dynamic 和 Compressed 行格式（三者格式很像）。
## COMPACT 行格式长什么样？
一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。
![[Pasted image 20250305214258.png]]
### 记录的额外信息
#### 1. 变长字段长度列表
varchar(n) 和 char(n)：char 是定长的，varchar 是变长的，所以在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面
这些变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**，**NULL 是不会存放在行格式中记录的真实数据部分里的，所以「变长字段长度列表」里不需要保存值为  NULL 的变长字段的长度。**![[Pasted image 20250305215810.png]]
> 为什么「变长字段长度列表」的信息要按照逆序存放？

「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。
> 每个数据库表的行格式都有「变长字段字节数列表」吗？

「变长字段长度列表」只出现在数据表有变长字段的时候。**当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了**。
#### 2. NULL 值列表
如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。

- 二进制位的值为`1`时，代表该列的值为 NULL。
- 二进制位的值为`0`时，代表该列的值不为 NULL。
NULL 值列表必须用整数个字节的位表示（1 字节 8 位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。最后NULL 值列表用十六进制表示。
 >每个数据库表的行格式都有「NULL 值列表」吗？

NULL 值列表也不是必须的。**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。
> 「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？

「NULL 值列表」的空间不是固定 1 字节的，可以创建两个字节空间的「NULL 值列表」等。
#### 3. 记录头信息
- delete_mask：标识此条数据是否被删除。
- next_record：下一条记录的位置。
- record_type：表示当前记录的类型，0 表示普通记录，1 表示 B+树非叶子节点记录，2 表示最小记录，3 表示最大记录
### 记录的真实数据
记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer。![[Pasted image 20250306083841.png]]
- row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id 不是必需的。
-  trx_id：事务 id，表示这个数据是由哪个事务生成的。trx_id 是必需的。
-  roll_pointer：这条记录上一个版本的指针。roll_pointer 是必需的。
## varchar(n) 中 n 最大取值为多少？
**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。
varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小。
### 单字段的情况
**一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead**。
storage overhead就是「变长字段长度列表」和「NULL 值列表」。**一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和「NULL 值列表」所占用的字节数的**。
**因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节**。
**在数据库表只有一个 varchar(n)  字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 =  65535 - 2 - 1 = 65532**。
### 多字段的情况
**如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL 值列表所占用的字节数 <= 65535**。
## 行溢出后，MySQL 是怎么处理的？
这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。
Compact 行格式在发生行溢出后的处理：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。![[Pasted image 20250306090152.png]]
Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。
这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。![[Pasted image 20250306090223.png]]
