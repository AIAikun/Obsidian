# MySQL 使用 like“%x“，索引一定会失效吗？ 
![[Pasted image 20250313091925.png]]
### 题目一 
题目 1 的数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段。
![[Pasted image 20250313091955.png]]
这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），我贴个第二条查询语句的执行计划结果图：
![[Pasted image 20250313092055.png]]
而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。
![[Pasted image 20250313092106.png]]
### 题目二
题目 2 的数据库表特别之处在于，只有两个字段，一个是主键索引 id，另外一个是二级索引 name。
![[Pasted image 20250313092308.png]]
针对题目 2 的数据表，第一条和第二条模糊查询语句也是一样可以走索引扫描，第二条查询语句的执行计划如下，Extra 里的 Using index 说明用上了覆盖索引：
![[Pasted image 20250313093817.png]]
我们来看一下第三条查询语句的执行计划（第四条也是一样的结果）：
![[Pasted image 20250313093834.png]]
首先，这张表的字段没有「非索引」字段，所以 `select *` 相当于 `select id,name`，然后**这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值 + 主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。**
但是执行计划里的 type 是 `index`，这代表着是通过全扫描二级索引的 B+ 树的方式查询到数据的，也就是遍历了整颗索引树。
而第一和第二条查询语句的执行计划中 type 是 `range`，表示对索引列进行范围查询，也就是利用了索引树的有序性的特点，通过查询比较的方式，快速定位到了数据行。
所以，type=range 的查询效率会比 type=index 的高一些。
### 总结
使用左模糊匹配（like "%xx"）并不一定会走全表扫描，关键还是看数据表中的字段。
如果数据库表中的字段只有主键 + 二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树 (type=index)。
我们都知道联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树 (type=index)，比如下图：![[Pasted image 20250313094353.png]]