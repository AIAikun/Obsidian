参考书籍：《算法笔记》（胡凡、曾磊著）
补充：C++中关于类&对象的学习  [参考](https://www.runoob.com/cplusplus/cpp-classes-objects.html)
# 排序
## 1. 插入排序
代码：cpp/insertionSort.cpp
测试数据：`5 6 5 4 7 3`
## 2. 归并排序
归并排序是一种基于“归并”思想的排序方式。2-路归并排序的原理是，将序列两两分组，将序列归并为[n/2]个组,组内单独排序；然后将这些组再两两归并，生成[n/4]个组，组内再单独排序；以此类推，直到只剩下一个组为止。归并排序的时间复杂度为O(nlogn)。
路归并排序的非递归实现主要考虑到这样一点：每次分组时组内元素个数上限都是2原次。于是就可以想到这样的思路：令生长 step 的初值为2，然后将数组中每 step个元素准为一组，将其内部进行排序（即把左 step/2个元素与右 step/2个元素合并，而若元素个数不超过step /2，则不操作）：再令step 乘以2重复上面的操作，直到step/2超过元素个数n。
代码：cpp/mergeSort.cpp
测试数据：`5 6 5 4 7 3`
## 3. 快速排序
快速排序的思路是
1. 调整序列中的元素，使当前序列最左端的元素在调整后满足左侧所有元素均不超过，该元素，右侧所有元素均大于该元素。
2. 对该元素的左侧和右侧分别进行1. 的调整，直到当前调整区的长度不超过1。
代码：cpp/quickSort.cpp
测试数据：`5 6 5 4 7 3`
## 4. 堆排序
一个堆来说，堆顶元素是最大的，因此在建堆完毕后，堆排序的直观思路就是取出堆顶元素，然后将堆的最后一个元素替换至堆顶，再进行一次针对堆顶元素的向下调整一如此重复，直到堆中只有一个元素为止。
具体实现时，为了节省空间，可以倒着遍历数组，假设当前访问到i号位，那么将堆顶元素与i号位的元素交换，接着在［1,i-1]范围内对堆项元素进行一次向下调整即可。
代码：cpp/headSort.cpp